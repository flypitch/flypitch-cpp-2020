%% For double-blind review submission, w/o CCS and ACM Reference (max submission space)
\documentclass[sigplan,10pt,review, anonymous]{acmart}

% note(jesse, October 01 2019, 04:00 PM): I'm getting weird typesetting authors when the `anonymous' option is removed

% add: anonymous
\settopmatter{printfolios=true,printccs=false,printacmref=false}
%% For double-blind review submission, w/ CCS and ACM Reference
%\documentclass[sigplan,review,anonymous]{acmart}\settopmatter{printfolios=true}
%% For single-blind review submission, w/o CCS and ACM Reference (max submission space)
%\documentclass[sigplan,review]{acmart}\settopmatter{printfolios=true,printccs=false,printacmref=false}
%% For single-blind review submission, w/ CCS and ACM Reference
%\documentclass[sigplan,review]{acmart}\settopmatter{printfolios=true}
%% For final camera-ready submission, w/ required CCS and ACM Reference
%\documentclass[sigplan]{acmart}\settopmatter{}


%% Conference information
%% Supplied to authors by publisher for camera-ready submission;
%% use defaults for review submission.
\acmConference[CPP'20]{The 9th ACM SIGPLAN International Conference on Certified Programs and Proofs}{January 20--21, 2020}{New Orleans, LA, USA}
\acmYear{2020}
\acmISBN{} % \acmISBN{978-x-xxxx-xxxx-x/YY/MM}
\acmDOI{} % \acmDOI{10.1145/nnnnnnn.nnnnnnn}
\startPage{1}

%% Copyright information
%% Supplied to authors (based on authors' rights management selection;
%% see authors.acm.org) by publisher for camera-ready submission;
%% use 'none' for review submission.
\setcopyright{none}
%\setcopyright{acmcopyright}
%\setcopyright{acmlicensed}
%\setcopyright{rightsretained}
%\copyrightyear{2018}           %% If different from \acmYear

%% Bibliography style
\bibliographystyle{ACM-Reference-Format}
%% Citation style
%\citestyle{acmauthoryear}  %% For author/year citations
%\citestyle{acmnumeric}     %% For numeric citations
%\setcitestyle{nosort}      %% With 'acmnumeric', to disable automatic
                            %% sorting of references within a single citation;
                            %% e.g., \cite{Smith99,Carpenter05,Baker12}
                            %% rendered as [14,5,2] rather than [2,5,14].
%\setcitesyle{nocompress}   %% With 'acmnumeric', to disable automatic
                            %% compression of sequential references within a
                            %% single citation;
                            %% e.g., \cite{Baker12,Baker14,Baker16}
                            %% rendered as [2,3,4] rather than [2-4].


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Note: Authors migrating a paper from traditional SIGPLAN
%% proceedings format to PACMPL format must update the
%% '\documentclass' and topmatter commands above; see
%% 'acmart-pacmpl-template.tex'.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%% Some recommended packages.
\usepackage{booktabs}   %% For formal tables:
                        %% http://ctan.org/pkg/booktabs
\usepackage{subcaption} %% For complex figures with subfigures/subcaptions
%% http://ctan.org/pkg/subcaption

\usepackage{color}
\definecolor{keywordcolor}{rgb}{0.7, 0.1, 0.1}   % red
\definecolor{tacticcolor}{rgb}{0.1, 0.2, 0.6}    % blue
\definecolor{commentcolor}{rgb}{0.4, 0.4, 0.4}   % grey
\definecolor{symbolcolor}{rgb}{0.0, 0.1, 0.6}    % blue
\definecolor{sortcolor}{rgb}{0.1, 0.5, 0.1}      % green
\definecolor{attributecolor}{rgb}{0.7, 0.1, 0.1} % red

\usepackage{listings}
\def\lstlanguagefiles{lstlean.tex}
\lstset{language=lean,breakatwhitespace,xleftmargin=0pt, basicstyle=\ttfamily\small}
\usepackage{stmaryrd}
\newcommand{\B}{\mathbb{B}}
\newcommand{\lil}{\lstinline}
\newcommand{\N}{\mathbb{N}}
\newcommand{\ZFC}{\mathsf{ZFC}}
\newcommand{\CH}{\mathsf{CH}}

\usepackage{amsthm}
% \theoremstyle{theorem}
\newtheorem{thm}{Theorem}[section]
\theoremstyle{definition}
\newtheorem{defn}{Definition}[section]
\DeclareMathOperator{\cf}{cf}

\usepackage{tikz-cd}

\begin{document}

%% Title information
\title{A Formal Proof of the Independence of the Continuum Hypothesis}
                                        %% [Short Title] is optional;
                                        %% when present, will be used in
                                        %% header instead of Full Title.
% \titlenote{with title note}             %% \titlenote is optional;
                                        %% can be repeated if necessary;
                                        %% contents suppressed with 'anonymous'
% \subtitle{Subtitle}                     %% \subtitle is optional
% \subtitlenote{with subtitle note}       %% \subtitlenote is optional;
                                        %% can be repeated if necessary;
                                        %% contents suppressed with 'anonymous'


%% Author information
%% Contents and number of authors suppressed with 'anonymous'.
%% Each author should be introduced by \author, followed by
%% \authornote (optional), \orcid (optional), \affiliation, and
%% \email.
%% An author may have multiple affiliations and/or emails; repeat the
%% appropriate command.
%% Many elements are not rendered, but should be provided for metadata
%% extraction tools.

%% Author with single affiliation.
\author{Jesse Michael Han}
% \authornote{with author1 note}          %% \authornote is optional;
                                        %% can be repeated if necessary
% \orcid{nnnn-nnnn-nnnn-nnnn}             %% \orcid is optional
\affiliation{
  % \position{Position1}
  \department{Department of Mathematics}              %% \department is recommended
  \institution{University of Pittsburgh}            %% \institution is required
  \streetaddress{4200 Fifth Ave}
  \city{Pittsburgh}
  \state{PA}
  \postcode{15260}
  \country{USA}                    %% \country is recommended
}
\email{jessemichaelhan@gmail.com}          %% \email is recommended

%% Author with two affiliations and emails.
\author{Floris van Doorn}
% \authornote{with author2 note}          %% \authornote is optional;
                                        %% can be repeated if necessary
\orcid{0000-0003-2899-8565}             %% \orcid is optional
\affiliation{
  % \position{Position2a}
  \department{Department of Mathematics}              %% \department is recommended
  \institution{University of Pittsburgh}            %% \institution is required
  \streetaddress{4200 Fifth Ave}
  \city{Pittsburgh}
  \state{PA}
  \postcode{15260}
  \country{USA}                    %% \country is recommended
}
\email{fpvdoorn@gmail.com}         %% \email is recommended

%% Abstract
%% Note: \begin{abstract}...\end{abstract} environment must come
%% before \maketitle command
\begin{abstract}
  We use Boolean-valued models and forcing to give a formal proof of the independence of the continuum hypothesis ($\mathsf{CH}$) in the Lean theorem prover. We use a forcing argument for both directions, using Cohen forcing to show that $\mathsf{CH}$ is unprovable and using $\sigma$-closed forcing to show that $\mathsf{CH}$ is not disprovable.
\end{abstract}


%TODO
%% 2012 ACM Computing Classification System (CSS) concepts
%% Generate at 'http://dl.acm.org/ccs/ccs.cfm'.
% \begin{CCSXML}
% <ccs2012>
% <concept>
% <concept_id>10011007.10011006.10011008</concept_id>
% <concept_desc>Software and its engineering~General programming languages</concept_desc>
% <concept_significance>500</concept_significance>
% </concept>
% <concept>
% <concept_id>10003456.10003457.10003521.10003525</concept_id>
% <concept_desc>Social and professional topics~History of programming languages</concept_desc>
% <concept_significance>300</concept_significance>
% </concept>
% </ccs2012>
% \end{CCSXML}

% \ccsdesc[500]{Software and its engineering~General programming languages}
% \ccsdesc[300]{Social and professional topics~History of programming languages}
%% End of generated code


%TODO
%% Keywords
%% comma separated list
\keywords{continuum hypothesis, forcing, Lean, set theory, ZFC} %% \keywords are mandatory in final camera-ready submission


%% \maketitle
%% Note: \maketitle command must come after title commands, author
%% commands, abstract environment, Computing Classification System
%% environment and commands, and keywords command.
\maketitle


\section{Introduction}
\label{section:intro}
The continuum hypothesis ($\mathsf{CH}$) states that there is no cardinality between $\omega$, the smallest infinite cardinal and $\mathfrak{c}$, the cardinality of the continuum.
It was introduced by Cantor \cite{cantor1878beitrag} in 1878 and was the very first problem on Hilbert's list of twenty-three outstanding problems in mathematics.
G\"odel \cite{godel1938consistency} proved in 1938 that $\mathsf{CH}$ was consistent with $\mathsf{ZFC}$, and later conjectured that $\mathsf{CH}$ is independent of $\mathsf{ZFC}$, i.e. neither provable nor disprovable from the $\mathsf{ZFC}$ axioms.
In 1963, Paul Cohen developed \emph{forcing} \cite{cohen-the-independence-of-the-continuum-hypothesis-1,cohen1964independence2}, which allowed him to prove the consistency of $\neg \mathsf{CH}$, and therefore complete the independence proof.
For this work, which marked the beginning of modern set theory, he was awarded a Fields medal---the only one to ever be awarded for a work in mathematical logic.

In this paper we describe the successful completion of the Flypitch project\footnote{\url{https://flypitch.github.io}} (\textbf{F}ormal\textbf{ly} \textbf{p}roving the \textbf{i}ndependence of \textbf{t}he \textbf{c}ontinuum \textbf{h}ypothesis).
For both parts of the independence of the continuum hypothesis, we use forcing to construct a Boolean-valued model of $\mathsf{ZFC}$.
To show that $\mathsf{CH}$ is consistent, we use $\sigma$-closed forcing, to collapse the cardinality of the continuum to $\aleph_1$.
To show that $\neg \mathsf{CH}$ is consistent, we use Cohen forcing, to add $\aleph_2$ many new real numbers, giving an injection from $\aleph_2$ into the continuum.
This part of the proof already appeared in \cite{DBLP:conf/itp/HanD19}, but we will repeat a summary of the proof in this paper.
This forcing argument to show that $\mathsf{CH}$ is consistent is not the proof that G\"odel gave in 1938, who instead used the constructible universe $L$, where $\mathsf{CH}$ holds. We decided to formalize this proof so that we used an forcing argument for both parts of the independence.

The method of forcing with Boolean-valued models was developed by Solovay and Scott in '65-'66 \cite{scott1967proof,scott-solovay} as a simplification of Cohen's method.
Some of these simplifications were incorporated by Shoenfield \cite{shoenfield1971unramified} into a general theory of forcing using partial orders, and it is in this form that forcing is usually practiced.
While both approaches have essentially the same mathematical content (see e.g. \cite{kunen2014set, jech2013set, moore2019method}), there are several reasons why we chose Boolean-valued models for our formalization:
\begin{itemize}
  \item \textbf{Modularity.}
  The theory of forcing with Boolean-valued models cleanly splits into several components
  (a general theory of Boolean-valued semantics for first-order logic, a library for calculations inside complete Boolean algebras, the construction of Boolean-valued models of set theory, and the specifics of the forcing argument itself)
  which could be formalized in parallel and then recombined.

  \item \textbf{Directness.}
  For the purposes of an independence proof, the Boolean-valued soundness theorem eliminates the need to produce a two-valued model.
  This approach also bypasses any requirement for the L\"owenheim-Skolem theorems, Mostowski collapse, countable transitive models, or genericity considerations for filters.

  \item \textbf{Novelty and reusability.}
  As far as we were able to tell, the Boolean-valued approach to forcing has never been formalized.
  Furthermore, while for the purposes of an independence proof, forcing with Boolean-valued models and forcing with countable transitive models accomplish the same thing, a general library for Boolean-valued semantics of a deeply embedded logic could be used for formal verification applications outside of set theory,
  e.g. to formalize the Boolean-valued semantics of stochastic $\lambda$-calculus \cite{scott2014stochastic, bacci2018boolean}.

  \item \textbf{Amenability to structural induction.}
  As with Coq, Lean is able to encode extremely complex objects and reason about their specifications using inductive types.
  However, the user must be careful to choose the encoding so that properties they wish to reason about are accessible by structural induction, which is the most natural mode of reasoning in the proof assistant.
  After observing (1) that the Aczel-Werner encoding of $\mathsf{ZFC}$ as an inductive type is essentially a special case of the recursive \emph{name} construction from forcing (c.f. Section \ref{section:boolean-semantics}),
  and (2) that the automatically-generated induction principle for that inductive type \emph{is} $\in$-induction,
  it is easy to see that this encoding can be modified to produce a Boolean-valued model of set theory where, again, $\in$-induction comes for free.
\end{itemize}

Our formalization is written in the Lean 3 theorem prover.
Lean is an interactive proof assistant under active development at Microsoft Research \cite{de2015lean, sebastian1}.
It implements the Calculus of Inductive Constructions and has a similar metatheory to Coq, adding definitional proof irrelevance, quotient types, and a noncomputable choice principle.
Our formalization makes as much use of the expressiveness of Lean's dependent type theory as possible, using constructions which are impossible or unwieldy to encode in HOL, much less ZF. Lean's ordinals and cardinals, which are defined as equivalence classes of well-ordered types, live one universe level up and play a crucial role in the forcing argument.
Also, the models of set theory we construct require as input an entire universe of types.
Finally, our encoding of first-order logic uses parameterized inductive types which ensures that type-correctness implies well-formedness. This eliminates the need for separate well-formedness proofs.

The results in this paper are not the most general possible results.
Instead of showing the consistency of $\mathsf{CH}$ we could have shown the consistency of the generalized continuum hypothesis $\mathsf{GCH}$, which states that $2^{\aleph_\alpha}=\aleph_{\alpha+1}$ for all ordinals $\alpha$.
The generalized continuum hypothesis is true in the constructible universe $L$, and its consistency can be shown by a forcing argument, but this forcing argument is significantly more involved than the forcing argument for $\mathsf{CH}$.
We could generalize the consistency of $\neg \mathsf{CH}$ to the consistency of $\mathfrak{c}=\aleph_\alpha$, for any cardinal $\aleph_\alpha$ with uncountable cofinality.
Or more generally, that on regular cardinals the function $\kappa\mapsto 2^\kappa$ can be any monotone function not contradicting K\"onig's Theorem ($\cf(2^\kappa)>\kappa$)~\cite{easton1970powers}.

\subsection{Proof Outline}
\label{subsection:intro:outline}
%TODO
Boolean-valued semantics, Forcing, cardinal collapse, independence of CH.

During the proof outline, also refer to the sections in the paper.
\section{First-order logic}
\label{section:fol}

The starting point for first-order logic is a \emph{language} of relation and function symbols.
We represent a language as a pair of $\N$-indexed families of types, each of which is to be thought of as the collection of relation (resp. function) symbols stratified by arity:
\begin{lstlisting}
structure Language : Type (u+1) :=
(functions : ℕ → Type u)
(relations : ℕ → Type u)
\end{lstlisting}

\subsection{Terms, Formulae and Proofs}
\label{subsection:fol:terms}
The main novelty of our implementation of first-order logic is the use of \emph{partially applied} terms and formulas, encoded in a parameterized inductive type where the $\N$ parameter measures the difference between the arity and the number of applications.
The benefit of this is that it is impossible to produce an ill-formed term or formula, because type-correctness is equivalent to well-formedness.
This eliminates the need for separate well-formedness proofs.

Fix a language $L$. We define the type of \textbf{preterms} as follows:
\begin{lstlisting}
inductive preterm (L : Language.{u}) :
    ℕ → Type u
| var : ℕ → preterm 0 -- notation `&`
| func {l : ℕ} : L.functions l → preterm l
| app {l : ℕ} :
    preterm (l + 1) → preterm 0 → preterm l
\end{lstlisting}
A member of \lil{preterm n} is a partially applied term.
If applied to \lil{n} terms, it becomes a term.
We define the type of well-formed terms \lil{term L} to be \lil{preterm L 0}.

There are other methods to define well-typed terms, for example using a nested inductive type with a constructor (which replaces the second and third constructor in our definition)
\begin{lstlisting}
| app : ∀ {l : ℕ}, L.functions l →
    vector term l → term
\end{lstlisting}
Here \lil{vector term l} is a $l$-tuple of terms.
Lean has limited support for nested inductive types, but defining definitions by recursion on a nested inductive type is inconvenient.

The type of \textbf{preformulas} is defined similarly:
\begin{lstlisting}
inductive preformula (L : Language.{u}) :
    ℕ → Type u
| falsum : preformula 0 -- notation ⊥
| equal : term L → term L → preformula 0
    -- notation ≃
| rel {l : ℕ}, L.relations l → preformula l
| apprel {l : ℕ}, preformula (l + 1) →
    term L → preformula l
| imp : preformula 0 → preformula 0 →
    preformula 0 -- notation ⟹
| all : preformula 0 → preformula 0
    -- notation ∀'
\end{lstlisting}
A member of \lil{preformula n} is a partially applied formula.
If applied to \lil{n} terms, it becomes a formula.
The type of well-formed formulas \lil{formula L} is defined to be \lil{preterm L 0}.
Implication is the only primitive binary connective and universal quantification is the only primitive quantifier. Since we use classical logic, we can define the other connectives and quantifiers from these.
In particular, we define negation \lil{∼ f} to be \lil{f ⟹ ⊥} and existential quantification \lil{∃' f} to be \lil{∼ ∀' ∼ f}.
Note that implication and the universal quantifier cannot be applied to performulas that are not fully applied.

We choose this definition of \lil{preformula} to mimic \lil{preterm}.
Of course, we could define an inductive type where the constructors \lil{rel} and \lil{apprel} were replaced by the single constructor
\begin{lstlisting}
| rel {l : ℕ} : L.relations l →
    vector term l → formula
\end{lstlisting}
This would not even result in a nested inductive type.
However, we found it more convenient to adapt operations and proofs from \lil{preterm} to \lil{preformula} using our definition.
Using vectors results in some extra proof steps for reasoning about vectors.
Our approach also results in some extra proof steps, but they are the same as the steps in the corresponding proofs for preterms.

We use de Bruijn indices to avoid variable shadowing. This means that the variable \lil{&m} under \lil{k} is bound if $m<k$ and otherwise represents the $(m-k)$-th free variable.
We define the usual operations of lifting and substitution for terms and formulas, needed when using de Bruijn variables.
We use the notation \lil{t ↑' n # m} to mean the preterm of preformula \lil{t} where all variables which are at least \lil{m} are increased by \lil{n}.
The lift \lil{t ↑' n # 0} is abbreviated to \lil{t ↑ n}.
The substitution \lil{t[s // n]} is defined to be the term or formula \lil{t} where all variables that represent the \lil{n}-th free variable are replaced by \lil{s}.
More specifically, if an occurrence of a variable \lil{&(n+k)} is under \lil{k} quantifiers, then it is replaced by \lil{s ↑ (n+k)}.
Variables \lil{&m} for $m>n+k$ are replaced by \lil{&(m-1)}.

Our proof system is a natural deduction calculus, and all rules are motivated to work well with backwards-reasoning. The type of proof trees is given by the following inductive family of types:
\begin{lstlisting}
inductive prf :
    set (formula L) → formula L → Type u
| axm Γ A : A ∈ Γ → prf Γ A
| impI Γ A B : prf (insert A Γ) B →
    prf Γ (A ⟹ B)
| impE Γ A B : prf Γ (A ⟹ B) → prf Γ A →
    prf Γ B
| falsumE Γ A : prf (insert ∼A Γ) ⊥ → prf Γ A
| allI Γ A : prf ((λ f, f ↑ 1) '' Γ) A →
    prf Γ (∀' A)
| allE₂ Γ A t : prf Γ (∀' A) →
    prf Γ (A[t // 0])
| ref Γ t : prf Γ (t ≃ t)
| subst₂ Γ s t f : prf Γ (s ≃ t) →
    prf Γ (f[s // 0]) → prf Γ (f[t // 0])
\end{lstlisting}
In \lil{allI} the notation \lil{(λ f, f ↑ 1) '' Γ} means lifting all free variables in \lil{Γ} by one.
A term of type \lil{prf Γ A}, denoted \lil{Γ ⊢ A}, is a proof tree encoding a derivation of $A$ from $\Gamma$.
We also define provability as the proposition stating that a proof tree exists.
\begin{lstlisting}
def provable (Γ : set (formula L)) (f : formula L) : Prop :=
nonempty (prf Γ f)
\end{lstlisting}
Our current formalization does not use proof trees in an essential way, but we defined them so that we can define manipulations on proof trees (like detour elimination) in future projects.
We prove various meta-theoretic properties about provability, like weakening and the substitution theorem.
\begin{lstlisting}
def weakening : Γ ⊆ Δ → Γ ⊢ A → Δ ⊢ A
def substitution : Γ ⊢ A →
    (λ f, f[s // n]) '' Γ ⊢ A[s // n]
\end{lstlisting}
\subsection{ZFC}
\label{subsection:fol:zfc}

set theory as a first-order language and ZFC as a first-order theory. Statement of CH.

\section{Boolean-valued semantics}
\label{section:boolean-semantics}

A \textbf{complete Boolean algebra} is a type $\B$ equipped with the structure of a Boolean algebra and additionally operations $\operatorname{Inf}$ and $\operatorname{Sup}$ (which we write as $\bigsqcap$ and $\bigsqcup$) returning the infimum and supremum of an arbitrary collection of members of $\B$.
We use $\sqcap, \sqcup, \implies, \top$, and $\bot$ to denote meet, join, material implication, and top/bottom elements.
For more details on complete Boolean algebras, we refer the reader to the textbook of Halmos-Givant \cite{givant2008introduction}.

\begin{defn}\label{def-boolean-valued-structure}
  Fix a language $L$ and a complete Boolean algebra $\B$. A \textbf{$\B$-valued structure} is a type $M$ with realizations of all functions and relations in the language and a $\B$-valued congruence relation for equality. More precisely, it is an instance of the following structure:
  \begin{lstlisting}
structure bStructure (L : Language.{u}) :=
(carrier : Type u)
(fun_map {n} : L.functions n →
    vector carrier n → carrier)
(rel_map {n} : L.relations n →
    vector carrier n → 𝔹)
(eq : carrier → carrier → 𝔹)
(eq_refl (x) : eq x x = ⊤)
(eq_symm (x y) : eq x y = eq y x)
(eq_trans (x y z) : eq x y ⊓ eq y z ≤ eq x z)
(fun_congr {n} (f : L.functions n)
    (x y : vector carrier n) :
    ⨅(map2 eq x y) ≤
    eq (fun_map f x) (fun_map f y))
(rel_congr {n} (R : L.relations n)
    (x y : vector carrier n) :
    ⨅(map2 eq x y) ⊓ rel_map R x ≤
    rel_map R y)
\end{lstlisting}
Above, ``\lstinline{⨅(map2 eq x y)}'' means ``the infimum of the list whose $i$th entry is \lil{eq} applied to \lil{x[i]} and \lil{y[i]}''.
\end{defn}

Given a preterm \lil{t} in the language, we can realize it in any $\B$-valued structure $M$.
For this, we need to know the free variables in \lil{t}.
To do this conveniently with de Bruijn variables, we say that a (pre)term \lil{t} is \emph{bounded by \lil{l}} if all free variables are less than \lil{l} (i.e. all variables under \lil{k} quantifiers are less than \lil{k+l}).
Given \lil{t : preterm n} which is bounded by \lil{l}, and a realization \lil{v : vector M l} of the free variables, we define the realization $\llbracket t \rrbracket_M^v : M^n \to M$ by structural recursion on $t$.

For a formula $\varphi$ we do the same: we define bounded (pre)formulae, and define an realization $\llbracket \varphi \rrbracket_M^v : M^n \to \B$ by structural recursion.
If $\varphi$ is a sentence, the realization in a structure is just a element of the boolean algebra: $\llbracket \varphi \rrbracket_M : \B$.

Since the truth values in a boolean-valued model live inside the boolean algebra $\B$ instead of just being true or false, we have to take a little care when stating the soundness theorem for boolean-valued models.
Usually, a soundness theorem states something like ``if $\varphi$ is provable from hypotheses in $\Gamma$ then in every model where $\Gamma$ holds, $\varphi$ also holds.''
With boolean truth-values, we need instead state it as an inequality of truth values. This motivates the following definition
\begin{defn}
We say that a set of sentences $\Gamma$ \emph{forces a sentence} $\varphi$, written $\Gamma \models_{\B}\varphi$, if for all non-empty $\B$-valued structures $M$ we have $\big(\bigsqcap_{\psi\in\Gamma}\big \llbracket \psi \rrbracket_M)\le\llbracket \varphi \rrbracket_M$.
\end{defn}
Using this definition, we can now state the boolean-valued soundness theorem:
\begin{lstlisting}
theorem boolean_soundness {Γ : set (sentence L)}
    {ϕ : sentence L} : Γ ⊢ ϕ → Γ ⊨[𝔹] ϕ
\end{lstlisting}
The proof is a straightforward structural induction.

\section{Boolean-valued models of set theory}
\label{subsection:fol:bset}
\paragraph{The Aczel encoding}
Our starting point is the Aczel encoding of \(\mathsf{ZFC}\) (\cite{aczel1978type, aczel1986type, aczel1982type}) into dependent type theory, later implemented in Coq by Werner \cite{werner1997sets}, and in Lean's \lstinline{mathlib} by Carneiro \cite{mario1}. The idea is to take a type universe \lstinline{Type u} and imitate the cumulative hierarchy construction with an inductive type:
\begin{lstlisting}
inductive pSet : Type (u+1)
| mk (α : Type u) (A : α → pSet) : pSet
\end{lstlisting}
Note that \lstinline{∅ := (pSet.mk empty empty.elim : pSet)} always exists, and plays the same role as the empty set at the bottom of the cumulative hierarchy. In order for the axiom of extensionality to hold, \lstinline{pSet} must be quotiented by \emph{extensional equivalence}, which is defined by structural recursion:

\begin{lstlisting}[basicstyle=\ttfamily\small]
def equiv : ∀ (x y : pSet), Prop
| ⟨α,A⟩ ⟨β,B⟩ := (∀a : α, ∃b : β, equiv (A a) (B b)) ∧ (∀b : β, ∃a : α, equiv (A a) (B b))
\end{lstlisting}

It is easy to furthermore define membership from equivalence and check that modulo extensional equivalence, \lstinline{pSet} is a model of \(\mathsf{ZFC}\).

\paragraph{Two roads to \lstinline{bSet}} We describe two ways by which one can start at the ordinary model of \(\mathsf{ZFC}\) \lstinline{pSet} and end with a Boolean-valued model \lstinline{bSet}.

First, note that we can construct a model of \(\mathsf{ZFC}\) roughly equivalent to \lstinline{pSet} as follows:

\begin{lstlisting}
inductive bSet : Type (u+1)
| mk (α : Type u) (A : α → bSet)
  (B : α → bool): bSet
\end{lstlisting}

At first glance, \lstinline{bSet} adds large amounts of unnecessary information---while with \lstinline{pSet}, anything pointed to by an indexing function \lstinline{A} is a member of a set, \lstinline{bSet} only counts what is also assigned \lstinline{tt : bool}---and we can reconstruct \lstinline{pSet} from \lstinline{bSet} by recursively discarding anything which is assigned \lstinline{ff : bool} anyways. However, if we remember that \lstinline{bool} is a complete Boolean algebra \lstinline{⟨bool, ⊤, ⊥, ⊓, ⊔, ⨅,⨆, ⟹⟩}, then an upshot of the definition of \lstinline{bSet} is that we can replace the obvious analogue of \lstinline{equiv}
\begin{lstlisting}
def equiv : ∀ (x y : bSet), Prop
| ⟨α,A,A'⟩ ⟨β,B,B'⟩ := (∀ a : α, A' a = tt → ∃ b : β, B' b = tt ∧ equiv₁ (A a) (B b)) ∧ (∀b : β, B' b = tt → ∃ a : α, A' a = tt ∧ equiv₁ (A a) (B b))
\end{lstlisting}
with a version which avoids propositional operations and only uses the operations of a complete Boolean algebra:\footnote{Assuming \lstinline{Prop ≃ bool}, which is provable using classical logic in Lean.}
\begin{lstlisting}[basicstyle=\ttfamily\small]
def equiv₂ : ∀ (x y : bSet), bool
| ⟨α,A,A'⟩ ⟨β,B,B'⟩ := ⨅ a : α, A' a ⟹ ⨆ b : β, B' b ⊓ equiv₂ (A a) (B b) ⊓  ⨅ b : β, B' b ⟹ ⨆ a : α, A' a ⊓ equiv₂ (A a) (B b)
\end{lstlisting}
Since this definition only interfaces with the typeclass of complete Boolean algebras, we can replace \lstinline{bool} by an arbitrary complete Boolean algebra \lstinline{𝔹} throughout, yielding: % note(jesse, October 03 2019, 05:06 PM): maybe should emphasize definition of membership instead of equality to make it clear that these things are Boolean-valued models of ZFC
\begin{lstlisting}
inductive bSet (𝔹 : Type u) [complete_boolean_algebra 𝔹]: Type (u+1)
| mk (α : Type u) (A : α → bSet)
  (B : α → bool): bSet
\end{lstlisting}
which we later verify is a \(\mathbb{B}\)-valued model of \(\ZFC\).

Second, we observe that the Aczel encoding is closely related to the recursive \emph{name}-construction from forcing, a key ingredient to building forcing extensions. Let \(\mathbb{P}\) be a poset. From e.g. Kunen \cite{kunen2014set}, Definition IV.2.5:

\begin{definition}
  A set \(\tau\) is a \(\mathbb{P}\)-name iff \(\tau\) is a relation and \(\forall \langle  \sigma, p\rangle \in \tau, \sigma \text{ is a \(\mathbb{P}\)-name and } p \in \mathbb{P}\).
\end{definition}

In particular, if \(\mathbb{P}\) is the singleton poset, then a \(\mathbb{P}\)-name is a set of \(\mathbb{P}\)-names, in the same way that a term of type \lstinline{pSet} is a type-indexed collection of terms of type \lstinline{pSet}. Reversing this observation, we replace \(\mathbb{P}\) with a complete Boolean algebra \(\mathbb{B}\) and generalize the definition of \lstinline{pSet.mk} with a third field, so that as in the case of \(\mathbb{P}\)-names, every element of a set is assigned an element (a ``Boolean truth-value'') of \(\mathbb{B}\):

\begin{lstlisting}
inductive bSet {𝔹 : Type u) : Type (u+1)
| mk (α: Type u) (A: α → bSet) (B: α→ 𝔹) : bSet
\end{lstlisting}
% Whatever is important in \lstinline{bvm}, \lstinline{bvm_extras}, \lstinline{bvm_extras2} for this argument.

Thus, \lstinline{bSet 𝔹} should be thought of as the type of \lstinline{𝔹}-names.

[...]

We summarize the relationship between the three ``large'' types currently in play:
\[
  \begin{tikzcd}
    % & \text{\lstinline{Type u+1}} & & \\
    \texttt{pSet} \arrow{rr}{\texttt{check}} & & \texttt{bSet } \mathbb{B} & \\
    & & & \\
    \texttt{ordinal.\{u\}} \arrow{uu}{\texttt{ordinal.mk}} \arrow{uurr} & & & % \\
    % \hspace{0mm}  \arrow[dashed, no head]{rrr } & & & \hspace{0mm} \\
    % & \mathbb{B} & & \\
    % & \text{\lstinline{Type u}} & &
  \end{tikzcd}
\]

We spell out the name of Lean ordinals and cardinals, and use (checked) Hebrew letters for their (Boolean-valued) set-theoretic counterparts, so that with respect to the above diagram, we have:
\[
  \begin{tikzcd}
    % & \text{\lstinline{Type u+1}} & & \\
    \aleph_1 \arrow[mapsto]{rr}{\text{\lstinline{check}}} & & \check{\aleph_1} & \\
    & & & \\
    \text{\lstinline{(aleph 1)}} \arrow[mapsto]{uu}{\texttt{ordinal.mk}} \arrow[mapsto]{uurr} & & & % \\
    % \hspace{0mm}  \arrow[dashed, no head]{rrr } & & & \hspace{0mm} \\
    % & \mathbb{B} & & \\
    % & \text{\lstinline{Type u}} & &
  \end{tikzcd}
\]


% TODO(jesse): add a note in the introduction on how Dana Scott was the first one to point out that the names could be taken at face value as a model of ZFC if one was willing to shift to a many-valued logic instead.


\section{Forcing} \label{section:forcing}
Our point of departure from conventional accounts of forcing with a poset \(\mathbb{P}\) over a countable transitive model \cite{kunen2014set, jech2013set}, which use a generic filter to ``evaluate'' the \lstinline{ℙ}-names and produce an ordinary model of \(\ZFC\), is to force with \emph{Boolean-valued models} of \(\ZFC\) instead. As initially observed by Scott and Solovay \cite{scott-solovay}, this obviates the need for countable transitive models, generic filters, or the truth and definability lemmas, and allows us to work only with the \lstinline{𝔹}-names.

However, the cost of taking the \lstinline{𝔹}-names at face value is that we must work with them as a \(\mathbb{B}\)-valued model (c.f. \ref{def-bModel}) of \(\mathsf{ZFC}\).

\subsection{Regular open algebras}
\begin{definition}
  Let $X$ be a topological space, and for any open set $U$, let $U^\perp$ denote the complement of the closure of $U$. The \textbf{regular open algebra} of a topological space $X$, written $\operatorname{RO}(X)$, is the collection of all open sets $U$ such that $U = (U^\perp)^\perp$, equipped with the structure of a complete Boolean algebra, with $x \sqcap y := x \cap y$, $x \sqcup y := ((x \cup y)^\perp)^\perp$, $\neg x := x^\perp$, and $\bigsqcup x_i := ((\bigcup x_i)^\perp)^\perp$.
\end{definition}

\subsection{Cohen forcing}
\begin{definition}
  The \textbf{Cohen poset} for adding $\aleph_2$-many Cohen reals is the collection of all finite partial functions $\aleph_2 \times \mathbb{N} \to \mathbf{2}$, ordered by reverse inclusion.
\end{definition}

In the formalization, the Cohen poset is represented as a \lstinline{structure} with three fields:
\begin{lstlisting}
structure 𝒞 : Type :=
  (ins : finset (ℵ₂.type × ℕ))
  (out : finset (ℵ₂.type × ℕ))
  (H : ins ∩ out = ∅)
\end{lstlisting}

%TODO(jesse): reword
That is, we identify a finite partial function $f$ with the triple \lil{⟨f.ins, f.out, f.H⟩}, where \lil{f.ins} is the preimage of $\{1\}$, \lil{f.out} is the preimage of $\{0\}$, and \lil{f.H} ensures well-definedness. While $f$ is usually defined as a finite partial function, we found that in practice $f$ is really only needed to give a finite partial specification of a subset of $\aleph_2 \times \mathbb{N}$ (i.e. a finite set \lil{f.ins} which \emph{must} be in the subset, and a finite set \lil{f.out} which \emph{must not} be in the subset), and chose this representation to make that information immediately accessible.

The Boolean algebra which we will use for forcing $\neg\mathsf{CH}$ is $\operatorname{RO}(2^{\aleph_2 \times \mathbb{N}})$. Unless stated otherwise, for the rest of this section, we put $\B := \operatorname{RO}(2^{\aleph_2 \times \mathbb{N}})$.

\begin{definition}
  We define the \textbf{canonical embedding} of the Cohen poset into $\B$ as follows:
  \begin{lstlisting}
def ι : 𝒞 → 𝔹 := λ p, {S | p.ins ⊆ S ∧ p.out ⊆ - S}
\end{lstlisting}
\end{definition}
That is, we send each \lil{c : 𝒞} to all the subsets which satisfy the specification given by \lil{c}. This is a clopen set, hence regular. Crucially, this embedding is \emph{dense}:
\begin{lstlisting}
lemma 𝒞_dense {b : 𝔹} (H : ⊥ < b) : ∃ p : 𝒞, ι p ≤ b
\end{lstlisting}
Recalling that $\leq$ in $\B$ is subset-inclusion, we see that this is essentially because the image of $\iota : \mathcal{C} \to \B$ \emph{is} the standard basis for the product topology. Our chosen encoding of the Cohen poset also made it easier to perform this identification when formalizing this proof.

\subsection{Collapse forcing} \label{subsection:collapse}
% note(jesse, October 01 2019, 04:11 PM): i think levy collapse only involves the collapse of strongly inaccessible cardinals, and that the collapsing argument we use goes by the name of σ-closed, ω-closed, countably closed forcing or maybe just collapse forcing? we should clarify this.

Whereas Cohen forcing creates a new injection \(\aleph_2 \hookrightarrow \mathcal{P}(\omega)\), we can use collapse forcing to create a new surjection \(\aleph_1 \twoheadrightarrow \mathcal{P}(\omega)\).

\begin{definition}\label{def-collapse-poset}
  We define \lstinline{ℙ_collapse} to be the poset of countable partial functions \(\aleph_1 \to \mathcal{P}(\omega)\). The principal open sets \[D_p := \{g : \aleph_1 \to \mathcal{P}(\omega) \hspace{2mm} | \hspace{2mm} g \text{ extends } p\} , \hspace{3mm} p \in \mathbb{P}_{\text{collapse}}\] form the basis of a topology \(\tau\) (finer than the product topology) on the function set \(\mathcal{P}(\omega)^{\aleph_1}\). Put \lstinline{𝔹_collapse :=} \(\operatorname{RO}\left(\mathcal{P}(\omega)^{\aleph_1}, \tau\right)\).
\end{definition}

\begin{itemize}
 \item To specify the surjection \(\aleph_1 \twoheadrightarrow \mathcal{P}(\omega)\), need to specify a subset of the powerset \(\mathcal{P}(\aleph_1 \times \mathcal{P}(\omega))\).

 \item Let \(p(\nu, S)\) be the (singleton) countable partial function which sends \(\nu : \aleph_1\) to \(S : \mathcal{P}(\omega)\).

 \item Then we can check that the indicator function
\[ (\nu, S) \mapsto D_{p(\nu,S)}, \]
induces a surjection in \lstinline{bSet 𝔹_collapse} from \(\check{\aleph_1}\) to \(\check{\mathcal{P}(\omega)}\).

 \item Then it remains to check that \(\check{\aleph_1} = \aleph_1\) and \(\mathcal{P}(\omega) = \check{\mathcal{P}(\omega)}\)  
\end{itemize}

\paragraph{Function reflection}

This follows from the following property: for any \lstinline{y : pSet}, and for any \lstinline{f : bSet 𝔹_collapse}, if \lstinline{bSet 𝔹_collapse} thinks that \(f : \check{\omega}  \to \check{y}\) is a function, then there exists a \(g : \omega \to y\) *in* \lstinline{pSet} such that \(\check{g} = \check{f}\).

As before, reflect a boolean-valued \(\forall \exists\) statement into the metatheory. The following lemma is always true:
%TODO(jesse): make this bigger
\begin{lstlisting}
lemma AE_of_check_func_check (x y : pSet.{u}) {f : bSet 𝔹} {Γ : 𝔹}
  (H : Γ ≤ is_func' (x̌) (y̌) f) (H_nonzero : ⊥ < Γ) :
  Π (i : x.type),
    ∃ (j : y.type ) (Γ' : 𝔹) (H_nonzero' : ⊥ < Γ') (H_le : Γ' ≤ Γ),
      Γ' ≤ (is_func' (x̌) (y̌) f) ∧ Γ' ≤ (pair ((x.func i)̌ ) ((y.func j)̌ )) ∈ᴮ f :=
\end{lstlisting}

Recursively applying this lemma, obtain values \(g_0, \dots, g_n, \dots\) such that

\[\bot < \dots < \left(\bigsqcap_{k \leq n} ((k, g_k) \in^{\mathbb{B}} g)\right) < \cdots < ((0 , g_0) \in^{\mathbb{B}} g)\]

The intersection of this chain thinks that \(g\) is the required lift of \(f\). In general, this intersection might be empty, but it is nonempty for \lstinline{𝔹_collapse}, (essentially) because the union of a chain of countable partial functions is again a countable partial function. By a denseness argument, \(g\) has the required property.

% partial functions in Lean, introduce the collapsing boolean algebra, show omega-closedness.


\subsection{Construction of $\aleph_1$} \label{subsection:forcing:aleph-1}

% Construction of $\aleph_1$.

\subsection{The independence of CH} \label{subsection:forcing:independence}

The final argument to show that this particular model satisfies CH.

\section{Related Work}
\label{section:related-work}
Compare with other formalization on the consistency of CH.


\section{Conclusions}
\label{section:conclusions}
Future work: construction of L, ZFC without function symbols, parser and better printer for FOL

%% Acknowledgments
\begin{acks}                            %% acks environment is optional
                                        %% contents suppressed with 'anonymous'
  %% Commands \grantsponsor{<sponsorID>}{<name>}{<url>} and
  %% \grantnum[<url>]{<sponsorID>}{<number>} should be used to
  %% acknowledge financial support and will be used by metadata
  %% extraction tools.
  The authors gratefully acknowlege the support by the
  \grantsponsor{GS100000001}{Alfred P. Sloan Foundation}{https://doi.org/10.1038/201765d0}, Grant
  No.~\grantnum{GS100000001}{G-2018-10067}.
\end{acks}

%% Bibliography
\bibliography{flypitch-cpp}

%% Appendix
\appendix
\section{Appendix}

Text of appendix \ldots

\end{document}
