%% For double-blind review submission, w/o CCS and ACM Reference (max submission space)
\documentclass[sigplan,10pt,review, cleveref, anonymous]{acmart}

\usepackage{cleveref}

% note(jesse, October 01 2019, 04:00 PM): I'm getting weird typesetting authors when the `anonymous' option is removed

% add: anonymous
\settopmatter{printfolios=true,printccs=false,printacmref=false}
%% For double-blind review submission, w/ CCS and ACM Reference
%\documentclass[sigplan,review,anonymous]{acmart}\settopmatter{printfolios=true}
%% For single-blind review submission, w/o CCS and ACM Reference (max submission space)
%\documentclass[sigplan,review]{acmart}\settopmatter{printfolios=true,printccs=false,printacmref=false}
%% For single-blind review submission, w/ CCS and ACM Reference
%\documentclass[sigplan,review]{acmart}\settopmatter{printfolios=true}
%% For final camera-ready submission, w/ required CCS and ACM Reference
%\documentclass[sigplan]{acmart}\settopmatter{}

%% Conference information
%% Supplied to authors by publisher for camera-ready submission;
%% use defaults for review submission.
\acmConference[CPP'20]{The 9th ACM SIGPLAN International Conference on Certified Programs and Proofs}{January 20--21, 2020}{New Orleans, LA, USA}
\acmYear{2020}
\acmISBN{} % \acmISBN{978-x-xxxx-xxxx-x/YY/MM}
\acmDOI{} % \acmDOI{10.1145/nnnnnnn.nnnnnnn}
\startPage{1}

%% Copyright information
%% Supplied to authors (based on authors' rights management selection;
%% see authors.acm.org) by publisher for camera-ready submission;
%% use 'none' for review submission.
\setcopyright{none}
%\setcopyright{acmcopyright}
%\setcopyright{acmlicensed}
%\setcopyright{rightsretained}
%\copyrightyear{2018}           %% If different from \acmYear

%% Bibliography style
\bibliographystyle{ACM-Reference-Format}
%% Citation style
%\citestyle{acmauthoryear}  %% For author/year citations
%\citestyle{acmnumeric}     %% For numeric citations
%\setcitestyle{nosort}      %% With 'acmnumeric', to disable automatic
                            %% sorting of references within a single citation;
                            %% e.g., \cite{Smith99,Carpenter05,Baker12}
                            %% rendered as [14,5,2] rather than [2,5,14].
%\setcitesyle{nocompress}   %% With 'acmnumeric', to disable automatic
                            %% compression of sequential references within a
                            %% single citation;
                            %% e.g., \cite{Baker12,Baker14,Baker16}
                            %% rendered as [2,3,4] rather than [2-4].


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Note: Authors migrating a paper from traditional SIGPLAN
%% proceedings format to PACMPL format must update the
%% '\documentclass' and topmatter commands above; see
%% 'acmart-pacmpl-template.tex'.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%% Some recommended packages.
\usepackage{booktabs}   %% For formal tables:
                        %% http://ctan.org/pkg/booktabs
\usepackage{subcaption} %% For complex figures with subfigures/subcaptions
%% http://ctan.org/pkg/subcaption

\usepackage{color}
\definecolor{keywordcolor}{rgb}{0.7, 0.1, 0.1}   % red
\definecolor{tacticcolor}{rgb}{0.1, 0.2, 0.6}    % blue
\definecolor{commentcolor}{rgb}{0.4, 0.4, 0.4}   % grey
\definecolor{symbolcolor}{rgb}{0.0, 0.1, 0.6}    % blue
\definecolor{sortcolor}{rgb}{0.1, 0.5, 0.1}      % green
\definecolor{attributecolor}{rgb}{0.7, 0.1, 0.1} % red

% TODO: replace \check and Ãå  by \widecheck
%% code from mathabx.sty and mathabx.dcl
%% This code is here to define the \widecheck control sequence without importing mathabx
\DeclareFontFamily{U}{mathx}{\hyphenchar\font45}
\DeclareFontShape{U}{mathx}{m}{n}{
      <5> <6> <7> <8> <9> <10>
      <10.95> <12> <14.4> <17.28> <20.74> <24.88>
      mathx10
      }{}
\DeclareSymbolFont{mathx}{U}{mathx}{m}{n}
\DeclareFontSubstitution{U}{mathx}{m}{n}
\DeclareMathAccent{\widecheck}{0}{mathx}{"71}
\DeclareMathAccent{\wideparen}{0}{mathx}{"75}

\usepackage{listings}
\def\lstlanguagefiles{lstlean.tex}
\lstset{language=lean,breakatwhitespace,xleftmargin=0pt, basicstyle=\ttfamily\small}
\usepackage{stmaryrd}
\newcommand{\B}{\mathbb{B}}
\newcommand{\lil}{\lstinline}
\newcommand{\N}{\mathbb{N}}
\newcommand{\ZFC}{\mathsf{ZFC}}
\newcommand{\CH}{\mathsf{CH}}

\usepackage{amsthm}
% \theoremstyle{theorem}
\newtheorem{thm}{Theorem}[section]
\theoremstyle{definition}
\newtheorem{defn}{Definition}[section]
\newtheorem{remark}{Remark}[section]
\DeclareMathOperator{\cf}{cf}
\DeclareMathOperator{\Ord}{Ord}

\usepackage{tikz-cd}

\begin{document}

%% Title information
\title{A Formal Proof of the Independence of the Continuum Hypothesis}
                                        %% [Short Title] is optional;
                                        %% when present, will be used in
                                        %% header instead of Full Title.
% \titlenote{with title note}             %% \titlenote is optional;
                                        %% can be repeated if necessary;
                                        %% contents suppressed with 'anonymous'
% \subtitle{Subtitle}                     %% \subtitle is optional
% \subtitlenote{with subtitle note}       %% \subtitlenote is optional;
                                        %% can be repeated if necessary;
                                        %% contents suppressed with 'anonymous'


%% Author information
%% Contents and number of authors suppressed with 'anonymous'.
%% Each author should be introduced by \author, followed by
%% \authornote (optional), \orcid (optional), \affiliation, and
%% \email.
%% An author may have multiple affiliations and/or emails; repeat the
%% appropriate command.
%% Many elements are not rendered, but should be provided for metadata
%% extraction tools.

%% Author with single affiliation.
\author{Jesse Michael Han}
% \authornote{with author1 note}          %% \authornote is optional;
                                        %% can be repeated if necessary
% \orcid{nnnn-nnnn-nnnn-nnnn}             %% \orcid is optional
\affiliation{
  % \position{Position1}
  \department{Department of Mathematics}              %% \department is recommended
  \institution{University of Pittsburgh}            %% \institution is required
  \streetaddress{4200 Fifth Ave}
  \city{Pittsburgh}
  \state{PA}
  \postcode{15260}
  \country{USA}                    %% \country is recommended
}
\email{jessemichaelhan@gmail.com}          %% \email is recommended

%% Author with two affiliations and emails.
\author{Floris van Doorn}
% \authornote{with author2 note}          %% \authornote is optional;
                                        %% can be repeated if necessary
\orcid{0000-0003-2899-8565}             %% \orcid is optional
\affiliation{
  % \position{Position2a}
  \department{Department of Mathematics}              %% \department is recommended
  \institution{University of Pittsburgh}            %% \institution is required
  \streetaddress{4200 Fifth Ave}
  \city{Pittsburgh}
  \state{PA}
  \postcode{15260}
  \country{USA}                    %% \country is recommended
}
\email{fpvdoorn@gmail.com}         %% \email is recommended

%% Abstract
%% Note: \begin{abstract}...\end{abstract} environment must come
%% before \maketitle command
\begin{abstract}
  We describe a formal proof of the independence of the continuum hypothesis (\(\mathsf{CH}\)) in the Lean theorem prover. We use Boolean-valued models to give forcing arguments for both directions, using Cohen forcing for the consistency of \(\neg \mathsf{CH}\) and a \(\sigma\)-closed forcing for the consistency of \(\mathsf{CH}\).

  % reasons for changes:

  % `Cohen forcing' means a very particular type of forcing which has a unique implementation on either the ctm or bvm side, but 'sigma-closed' is merely a combinatorial condition on a forcing poset/boolean algebra the same way that 'kappa-cc' is

  % avoid double negation e.g. 'not disprovable' by formulating in terms of consistency instead
  % i doubt anyone will be confused by this and we'll have to explain somewhere why the soundness theorem lets us use consistency results to prove unprovability results anyways

% We use Boolean-valued models and forcing to give a formal proof of the independence of the continuum hypothesis ($\mathsf{CH}$) in the Lean theorem prover. We use a forcing argument for both directions, using Cohen forcing to show that $\mathsf{CH}$ is unprovable and using $\sigma$-closed forcing to show that $\mathsf{CH}$ is not disprovable.
\end{abstract}


%TODO
%% 2012 ACM Computing Classification System (CSS) concepts
%% Generate at 'http://dl.acm.org/ccs/ccs.cfm'.
% \begin{CCSXML}
% <ccs2012>
% <concept>
% <concept_id>10011007.10011006.10011008</concept_id>
% <concept_desc>Software and its engineering~General programming languages</concept_desc>
% <concept_significance>500</concept_significance>
% </concept>
% <concept>
% <concept_id>10003456.10003457.10003521.10003525</concept_id>
% <concept_desc>Social and professional topics~History of programming languages</concept_desc>
% <concept_significance>300</concept_significance>
% </concept>
% </ccs2012>
% \end{CCSXML}

% \ccsdesc[500]{Software and its engineering~General programming languages}
% \ccsdesc[300]{Social and professional topics~History of programming languages}
%% End of generated code

%% Keywords
%% comma separated list
\keywords{continuum hypothesis, forcing, Lean, set theory, ZFC} %% \keywords are mandatory in final camera-ready submission


%% \maketitle
%% Note: \maketitle command must come after title commands, author
%% commands, abstract environment, Computing Classification System
%% environment and commands, and keywords command.
\maketitle


\section{Introduction}
\label{section:intro}
The continuum hypothesis ($\mathsf{CH}$) states that there is no cardinality between $\omega$, the smallest infinite cardinal and $\mathfrak{c}$, the cardinality of the continuum.
It was introduced by Cantor \cite{cantor1878beitrag} in 1878 and was the very first problem on Hilbert's list of twenty-three outstanding problems in mathematics.
G\"odel \cite{godel1938consistency} proved in 1938 that $\mathsf{CH}$ was consistent with $\mathsf{ZFC}$, and later conjectured that $\mathsf{CH}$ is independent of $\mathsf{ZFC}$, i.e. neither provable nor disprovable from the $\mathsf{ZFC}$ axioms.
In 1963, Paul Cohen developed \emph{forcing} \cite{cohen-the-independence-of-the-continuum-hypothesis-1,cohen1964independence2}, which allowed him to prove the consistency of $\neg \mathsf{CH}$, and therefore complete the independence proof.
For this work, which marked the beginning of modern set theory, he was awarded a Fields medal---the only one to ever be awarded for a work in mathematical logic.

In this paper we describe the successful completion of the Flypitch project\footnote{\url{https://flypitch.github.io}} (\textbf{F}ormal\textbf{ly} \textbf{p}roving the \textbf{i}ndependence of \textbf{t}he \textbf{c}ontinuum \textbf{h}ypothesis).
For both parts of the independence of the continuum hypothesis, we use forcing to construct a Boolean-valued model of $\mathsf{ZFC}$.
To show that $\mathsf{CH}$ is consistent, we use $\sigma$-closed forcing, to collapse the cardinality of the continuum to $\aleph_1$.
To show that $\neg \mathsf{CH}$ is consistent, we use Cohen forcing, to add $\aleph_2$ many new real numbers, giving an injection from $\aleph_2$ into the continuum.
The consistency of $\neg \mathsf{CH}$ already appeared in \cite{DBLP:conf/itp/HanD19}, and we will summarize this proof briefly.
This forcing argument to show that $\mathsf{CH}$ is consistent is not the proof that G\"odel gave in 1938, who instead used the constructible universe $L$, where $\mathsf{CH}$ holds. We decided to formalize this proof so that we used an forcing argument for both parts of the independence.

The method of forcing with Boolean-valued models was developed by Solovay and Scott in '65-'66 \cite{scott1967proof,scott-solovay} as a simplification of Cohen's method.
Some of these simplifications were incorporated by Shoenfield \cite{shoenfield1971unramified} into a general theory of forcing using partial orders, and it is in this form that forcing is usually practiced.
While both approaches have essentially the same mathematical content (see e.g.\ \cite{kunen2014set, jech2013set, moore2019method}), there are several reasons why we chose Boolean-valued models for our formalization.
The main reason is the directness of forcing with Boolean-valued models, which bypasses the need for the L\"owenheim-Skolem theorems, Mostowski collapse, countable transitive models, or genericity considerations for filters.

% TODO(Floris): maybe move to introduction of section on boolean-valued semantics? I already made a similar point in my section on boolean-valued models of set theory

% Instead, we had to set up a library for Boolean-valued models, including a soundness theorem for Boolean-valued models, but this was similar to the library for ordinary two-valued models.

%Note: the intent of the original form of this paragraph was to imply that the modularity of our library is a consequence of our choice to use Boolean-valued models

Moreover, the theory of forcing with Boolean-valued models splits into several parts, allowing us formalize different components in parallel and later recombine them. Some of these components include: a general theory of Boolean-valued semantics for first-order logic, a library for calculations inside complete Boolean algebras, and a construction of Boolean-valued models of set theory.

% We made sure that the individual components of this formalization are reusable for other projects, e.g.\ to formalize the Boolean-valued semantics of stochastic $\lambda$-calculus~\cite{scott2014stochastic, bacci2018boolean}.

%TODO: maybe this is better in the main text. We can mention it briefly here.
% \textbf{Amenability to structural induction.}
% As with Coq, Lean is able to encode extremely complex objects and reason about their specifications using inductive types.
% However, the user must be careful to choose the encoding so that properties they wish to reason about are accessible by structural induction, which is the most natural mode of reasoning in the proof assistant.
% After observing (1) that the Aczel-Werner encoding of $\mathsf{ZFC}$ as an inductive type is essentially a special case of the recursive \emph{name} construction from forcing (c.f. \ref{section:boolean-semantics}),
% and (2) that the automatically-generated induction principle for that inductive type \emph{is} $\in$-induction,
% it is easy to see that this encoding can be modified to produce a Boolean-valued model of set theory where, again, $\in$-induction comes for free.

Our formalization\footnote{\url{https://github.com/flypitch/flypitch}} is written in the Lean 3 theorem prover, building on top of \textsf{mathlib}~\cite{mathlib}. % TODO(after review): update reference
Lean is an interactive proof assistant under active development at Microsoft Research~\cite{de2015lean, ullrich2019counting}.
It implements the Calculus of Inductive Constructions and has a similar metatheory to Coq, adding definitional proof irrelevance, quotient types, and a noncomputable choice principle.
Our formalization makes as much use of the expressiveness of Lean's dependent type theory as possible, using constructions which are impossible or unwieldy to encode in HOL, much less ZF.
We crucially use the types of cardinals and ordinals defined in \textsf{mathlib}, which are defined as equivalence classes of (well-ordered) types, live one universe level higher than the types used to construct them, and our models of set theory require as input an entire universe of type. Our encoding of first-order logic also uses parameterized inductive types which ensure that type-correctness implies well-formedness, eliminating the need for separate well-formedness proofs.

\subsection{Proof Outline}
\label{subsection:intro:outline}
$\ZFC$ is a collection of first-order sentences in the language of set theory. For convenience, we conservatively extend this language with five function symbols (see \Cref{subsection:fol:zfc}) which make it easier to formulate $\CH$. Our goal is to show that we cannot construct proofs\footnote{By proof we mean a natural deduction tree (see \Cref{subsection:fol:terms}).} of either $\CH$ or $\neg\CH$ from $\ZFC$.

The usual method to show that a statement is unprovable is to construct a model where the statement is false, and apply the soundness theorem; our method is similar, except that we use Boolean-valued models (see \Cref{section:boolean-semantics}).
The difference between Boolean-valued models and ordinary models is that the truth values in a Boolean-valued model \lil{M} live in a complete Boolean algebra \lil{(ùîπ, ‚äì, ‚äî, ‚®Ö, ‚®Ü,‚ä•,‚ä§)}.
This means that, e.g.\ equality is interpreted as a function \lil{eq : M ‚Üí M ‚Üí ùîπ} satisfying \lil{ùîπ}-valued reflexivity, symmetry, and transitivity (for example, transitivity is formulated as \lil{eq(x, y) ‚äì eq(y, z) ‚â§ eq(x, z)} for all \lil{x, y, z}).
All interpretations of function symbols and relation symbols in \lil{M} must satisfy \lil{ùîπ}-valued congruence lemmas with respect to equality.
Our task is now to construct two Boolean-valued models of $\ZFC$, one where $\CH$ holds, and one where $\CH$ fails.
We then apply the soundness theorem for Boolean-valued models to show that $\CH$ is independent from $\ZFC$.

For any complete Boolean algebra $\mathbb{B}$ we can construct the type of $\mathbb{B}$-valued sets, or \lil{bSet ùîπ} (see \Cref{section:bset}).
% An element of \lil{x : bSet ùîπ} has three components:
% \begin{itemize}
% \item An indexing type \lil{Œ± : Type};
% \item A function \lil{A : Œ± ‚Üí bSet ùîπ} pointing to the (possible) elements of \lil{x};
% \item A \lil{ùîπ}-valued predicate \lil{B : Œ± ‚Üí ùîπ} which expresses that \lil{A a ‚àà x} has truth value (at least) \lil{B a}.
% \end{itemize}
Now the fundamental theorem of forcing states that \lil{bSet ùîπ} forms a Boolean-valued model of $\ZFC$.
\lil{bSet ùîπ} is a generalization of the Aczel encoding of set theory \cite{aczel1978type}, which is called \lil{pSet} in Lean.
In this encoding, the third component is missing.
We can also interpret \lil{pSet} as \lil{bSet unit}, where \lil{unit} is the trivial Boolean algebra (with $\top=\bot$).

The properties of \lil{bSet ùîπ} vary wildly depending on the choice of the complete Boolean algebra \lil{ùîπ}.
There is always a map \lil{check : pSet ‚Üí bSet ùîπ}, $x \mapsto \widecheck{x}$; $\widecheck{x}$ might have different properties than $x$, but \(\Delta_0\) properties (i.e. definable with only bounded quantification) are always preserved. In particular, \lil{bSet ùîπ} thinks $\widecheck{\omega}$ is $\omega$.
We now have to choose two appropriate complete Boolean algebras \lil{ùîπ} such that in \lil{bSet ùîπ}, the formula $\CH$ is true ($\top$) in one model and $\CH$ is false ($\bot$) in the other.
This is where forcing comes in (see \Cref{section:forcing}).

% To force the negation of the continuum hypothesis, we define Cantor space $2^{\aleph_2 \times \mathbb{N}}$ with its usual product topology (see TODO).
% Then let $\B_{\mathsf{cohen}}$ be the regular open algebra of the Cantor space (a set $O$ is a regular open if $O$ is equal to the interior of the closure of $O$).
% Now $\B$ is a complete Boolean algebra, so \lil{bSet ùîπ} models $\ZFC$.
% Internally to this model we can construct an injection $\widetilde{\chi} : \aleph_2 \to \mathcal{P}(\omega)$, in the following way.
% For each $\nu \in \aleph_2$, we associate the $\B$-valued characteristic function $\chi_\nu : \mathbb{N} \to \B$ by $n \mapsto \{f \mid f(\nu, n) = 1\}$.
% This induces an subset $\widetilde{\chi_{\nu}} \subseteq \mathbb{N}$ internal to \lil{bSet ùîπ}, which is called a \emph{Cohen real}.
% This way we obtain an function \(\widecheck{\aleph_2} \to \mathcal{P}(\mathbb{N})\) internal to \lil{bSet ùîπ}.
% We can now show that \lil{bSet ùîπ} thinks this function is injective, and we finish by showing that \lil{bSet ùîπ} thinks that \(\widecheck{\aleph_2}\) is $\aleph_2$ to show that $\neg\CH$ holds in \lil{bSet ùîπ}.
% The proof that \lil{bSet ùîπ} preserves cardinal numbers is really the technical heart of the matter, and relies on a combinatorial property of $\B$ called the \emph{countable chain condition} (CCC).
% The proof that $\B$ has the CCC requires a detailed combinatorial analysis of the basis of the product topology for $2^{\aleph_2 \times \mathbb{N}}$.
% We handle this with a general result in transfinite combinatorics called the \emph{$\Delta$-system lemma}.
% % we can omit the last two sentences, if needed

% For the other direction, to force the continuum hypothesis, we define the collapse poset to be the poset of countable partial functions
% \(\mathbb{P}_{\mathsf{collapse}} := \aleph_1 \rightharpoonup \mathcal{P}(\omega)\), and topologize $\mathcal{P}(\omega)^{\aleph_1}$ with the basis of opens
% \[\left\{ D_p := \{g : \aleph_1 \to \mathcal{P}(\omega) \mid g \text{ extends } p\} \right\}_{p \in \mathbb{P}_{\mathsf{collapse}}}\]

% The collapse algebra $\mathbb{B}_{\mathsf{collapse}}$ is now defined to be the regular opens in this topology.
% In the resulting model \lil{bSet ùîπ} we can construct a surjection \(F : \aleph_1 \twoheadrightarrow \mathcal{P}(\omega)\). (TODO) (see TODO)
% This depends on \(\sigma\)-closedness (TODO).

Traditional presentations of forcing, even with Boolean-valued models (e.g. \cite{bell2011set}, \cite{jech2013set}), are careful to stay within the foundations of $\mathsf{ZFC}$, emphasizing that all arguments may be performed internal to a model of $\mathsf{ZFC}$, etc. In order to formalize these set-theoretic arguments in a type-theoretic metatheory, it is important to separate their mathematical content from their metamathematical content. It is not immediately clear what parts of these arguments use their set-theoretic foundation in an essential way and require modification in the passage to set theory. Our formalization clarifies some of these questions.

Our formalization uses custom domain-specific tactics and automation throughout, notably a tactic library for simulating natural deduction proofs inside a complete Boolean algebra \Cref{section:metaprogramming}). This is another advantage of using a proof assistant: the bookkeeping of Boolean truth-values, sometimes regarded as a tedious aspect of the Boolean-valued approach to forcing, can be hidden via automation.

\subparagraph*{Sources} % TODO: fully incorporate this section into related work(?)
Our strategy for constructing a Boolean-valued model in which $\mathsf{CH}$ fails is a synthesis of the proofs in the textbooks of Bell (\cite{bell2011set}, Chapter 2) and Manin (\cite{manin2009course}, Chapter 8).
For the $\Delta$-system lemma, we follow Kunen (\cite{kunen2014set}, Chapters 1 and 5).
There is no good reference for the Boolean-valued model where $\CH$ holds.
A conventional argument using filters is given in Weaver \cite{weaver2014forcing}, which we adapted to Boolean-valued models.
See also the Related Work (\Cref{section:related-work}).

% \subparagraph*{Viewing the formalization}
% The code blocks in this paper were taken directly from our formalization, but for the sake of readability, we sometimes omit or modify universe levels, type ascriptions, and casts. We refer the interested reader to our repository (see Supplemental Material on page 1) which contains a guide on compiling and navigating the source files of the project.

\section{First-order logic}
\label{section:fol}

The starting point for first-order logic is a \emph{language} of relation and function symbols.
We represent a language as a pair of $\N$-indexed families of types, each of which is to be thought of as the collection of relation (resp. function) symbols stratified by arity:
\begin{lstlisting}
structure Language : Type (u+1) :=
(functions : ‚Ñï ‚Üí Type u)
(relations : ‚Ñï ‚Üí Type u)
\end{lstlisting}
\subsection{Terms, Formulae and Proofs}
\label{subsection:fol:terms}
The main novelty of our implementation of first-order logic is the use of \emph{partially applied} terms and formulas, encoded in a parameterized inductive type where the $\N$ parameter measures the difference between the arity and the number of applications.
The benefit of this is that it is impossible to produce an ill-formed term or formula, because type-correctness is equivalent to well-formedness.
This eliminates the need for separate well-formedness proofs.

Fix a language $L$. We define the type of \textbf{preterms} as follows:
\begin{lstlisting}
inductive preterm (L : Language.{u}) :
    ‚Ñï ‚Üí Type u
| var : ‚Ñï ‚Üí preterm 0 -- notation `&`
| func {l : ‚Ñï} : L.functions l ‚Üí preterm l
| app {l : ‚Ñï} :
    preterm (l + 1) ‚Üí preterm 0 ‚Üí preterm l
\end{lstlisting}
A member of \lil{preterm n} is a partially applied term.
If applied to \lil{n} terms, it becomes a term.
We define the type of well-formed terms \lil{term L} to be \lil{preterm L 0}.

There are other methods to define well-typed terms, for example using a nested inductive type with a constructor (which replaces the second and third constructor in our definition)
\begin{lstlisting}
| app : ‚àÄ {l : ‚Ñï}, L.functions l ‚Üí
    vector term l ‚Üí term
\end{lstlisting}
Here \lil{vector term l} is a $l$-tuple of terms.
Lean has limited support for nested inductive types, but defining definitions by recursion on a nested inductive type is inconvenient.

The type of \textbf{preformulas} is defined similarly:
\begin{lstlisting}
inductive preformula (L : Language.{u}) :
    ‚Ñï ‚Üí Type u
| falsum : preformula 0 -- notation ‚ä•
| equal : term L ‚Üí term L ‚Üí preformula 0
    -- notation ‚âÉ
| rel {l : ‚Ñï}, L.relations l ‚Üí preformula l
| apprel {l : ‚Ñï}, preformula (l + 1) ‚Üí
    term L ‚Üí preformula l
| imp : preformula 0 ‚Üí preformula 0 ‚Üí
    preformula 0 -- notation ‚üπ
| all : preformula 0 ‚Üí preformula 0
    -- notation ‚àÄ'
\end{lstlisting}
A member of \lil{preformula n} is a partially applied formula.
If applied to \lil{n} terms, it becomes a formula.
The type of well-formed formulas \lil{formula L} is defined to be \lil{preterm L 0}.
Implication is the only primitive binary connective and universal quantification is the only primitive quantifier. Since we use classical logic, we can define the other connectives and quantifiers from these.
In particular, we define negation \lil{‚àº f} to be \lil{f ‚üπ ‚ä•} and existential quantification \lil{‚àÉ' f} to be \lil{‚àº ‚àÄ' ‚àº f}.
Note that implication and the universal quantifier cannot be applied to performulas that are not fully applied.

We choose this definition of \lil{preformula} to mimic \lil{preterm}.
Of course, we could define an inductive type where the constructors \lil{rel} and \lil{apprel} were replaced by the single constructor
\begin{lstlisting}
| rel {l : ‚Ñï} : L.relations l ‚Üí
    vector term l ‚Üí formula
\end{lstlisting}
This would not even result in a nested inductive type.
However, we found it more convenient to adapt operations and proofs from \lil{preterm} to \lil{preformula} using our definition.
Using vectors results in some extra proof steps for reasoning about vectors.
Our approach also results in some extra proof steps, but they are the same as the steps in the corresponding proofs for preterms.

We use de Bruijn indices to avoid variable shadowing. This means that the variable \lil{&m} under \lil{k} is bound if $m<k$ and otherwise represents the $(m-k)$-th free variable.
We define the usual operations of lifting and substitution for terms and formulas, needed when using de Bruijn variables.
We use the notation \lil{t ‚Üë' n # m} to mean the preterm of preformula \lil{t} where all variables which are at least \lil{m} are increased by \lil{n}.
The lift \lil{t ‚Üë' n # 0} is abbreviated to \lil{t ‚Üë n}.
The substitution \lil{t[s // n]} is defined to be the term or formula \lil{t} where all variables that represent the \lil{n}-th free variable are replaced by \lil{s}.
More specifically, if an occurrence of a variable \lil{&(n+k)} is under \lil{k} quantifiers, then it is replaced by \lil{s ‚Üë (n+k)}.
Variables \lil{&m} for $m>n+k$ are replaced by \lil{&(m-1)}.

Our proof system is a natural deduction calculus, and all rules are motivated to work well with backwards-reasoning. The type of proof trees is given by the following inductive family of types:
\begin{lstlisting}
inductive prf :
    set (formula L) ‚Üí formula L ‚Üí Type u
| axm Œì A : A ‚àà Œì ‚Üí prf Œì A
| impI Œì A B : prf (insert A Œì) B ‚Üí
    prf Œì (A ‚üπ B)
| impE Œì A B : prf Œì (A ‚üπ B) ‚Üí prf Œì A ‚Üí
    prf Œì B
| falsumE Œì A : prf (insert ‚àºA Œì) ‚ä• ‚Üí prf Œì A
| allI Œì A : prf ((Œª f, f ‚Üë 1) '' Œì) A ‚Üí
    prf Œì (‚àÄ' A)
| allE‚ÇÇ Œì A t : prf Œì (‚àÄ' A) ‚Üí
    prf Œì (A[t // 0])
| ref Œì t : prf Œì (t ‚âÉ t)
| subst‚ÇÇ Œì s t f : prf Œì (s ‚âÉ t) ‚Üí
    prf Œì (f[s // 0]) ‚Üí prf Œì (f[t // 0])
\end{lstlisting}
In \lil{allI} the notation \lil{(Œª f, f ‚Üë 1) '' Œì} means lifting all free variables in \lil{Œì} by one.
A term of type \lil{prf Œì A}, denoted \lil{Œì ‚ä¢ A}, is a proof tree encoding a derivation of $A$ from $\Gamma$.
We also define provability as the proposition stating that a proof tree exists.
\begin{lstlisting}
def provable (Œì : set (formula L)) (f : formula L) :
    Prop :=
nonempty (prf Œì f)
\end{lstlisting}
Our current formalization does not use proof trees in an essential way, but we defined them so that we can define manipulations on proof trees (like detour elimination) in future projects.
We prove various meta-theoretic properties about provability, like weakening and the substitution theorem.
\begin{lstlisting}
def weakening : Œì ‚äÜ Œî ‚Üí Œì ‚ä¢ A ‚Üí Œî ‚ä¢ A
def substitution : Œì ‚ä¢ A ‚Üí
    (Œª f, f[s // n]) '' Œì ‚ä¢ A[s // n]
\end{lstlisting}
\subsection{ZFC}
\label{subsection:fol:zfc}

Usually, the language of set theory has one binary relation symbol and no function symbols.
In order to make the language a bit easier to work with, and to formulate the continuum hypothesis in a manageable way, we additionally add five function symbols to our language.
The five symbols we add are for the empty set \(\varnothing\), ordered pairs \(({-},{-})\), natural numbers \(\omega\), the power set \(\mathcal{P}({-})\) and the union \(\bigcup({-})\).
This gives a conservative extension of the regular theory of ZFC, because they are all definable.
As part of our future work, we want to formalize these facts, so that we actually prove the independence of the continuum hypothesis in a language with only one non-logical symbol.

The theory \(\ZFC\) we use consists of eight axioms and a strong version of the axiom schema of collection.
Five of the axioms characterize the function symbols we added.
The axioms of empty set, and powerset are similar to the usual formulation, except that we use the function symbols explicitly.
We don't uniquely characterize ordered pairs, but specify the equality on ordered pairs:
\[(x,y)=(z,w) \iff x = z \wedge y = w.\]
We don't have the usual axiom of pairing, but this axiom is derivable from the other axioms.
Our version of the axiom of infinity is a bit different to the usual axiom of infinity, which only specifies that there is an infinite set. Instead, we specify $\omega$ as the least limit ordinal.

In addition to the axioms characterizing the function symbols, we have the axioms of extensionality and regularity and Zorn's lemma.
Our version of Zorn's lemma is states that any non-empty collection of sets closed under unions of $\in$-chains has a maximal element.
Finally, the axiom schema of collection we use states that for every formula \(\varphi(x,y,\vec p)\) we have the axiom stating that if \(\varphi(x,y,\vec p)\) is a total relation with parameters \(\vec p\), then its image is a set:
\begin{gather*}
\forall p \forall u, (\forall x \in u, \exists y, \varphi(x,y,p)) \Rightarrow\\
(\exists v, \forall w, w \in v \iff \exists z \in u, \varphi(z,w,p)).
\end{gather*}

Now the continuum hypothesis \(\CH\) we use states that there is no ordinal between \(\omega\) and \(\mathcal{P}(\omega)\). It is defined to be the sentence
\[\CH:=\forall x, \Ord(x) \Rightarrow x \le \omega \vee \mathcal{P}(\omega) \le x,\]
where \(\Ord(x)\) means ``\(x\) is an ordinal'' and \(x \le y\) means that there is a surjection from a subset of \(y\) to \(x\). In code, we can formulate the \(\CH\) as follows.
\begin{lstlisting}
def CH_formula : formula L_ZFC' :=
‚àÄ' (is_ordinal ‚üπ
  leq_f[omega_t//1] ‚äî leq_f[Powerset_t omega_t//0])
\end{lstlisting}
Here the substitution ensures that the inequality \lil{leq_f} is applied to the correct arguments, and \lil{‚äî} is notation for disjunction.

\section{Boolean-valued semantics}
\label{section:boolean-semantics}

A \textbf{complete Boolean algebra} is a Boolean algebra $\B$ with as additional operations the infimum $\bigsqcap$ and supremum $\bigsqcup$ of any subset of $\B$.
We use $\sqcap, \sqcup, \implies, \top$, and $\bot$ to denote meet, join, material implication, and top/bottom elements.
For more details on complete Boolean algebras, we refer the reader to the textbook of Halmos-Givant~\cite{givant2008introduction}.

\begin{defn}\label{def-boolean-valued-structure}
  Fix a language $L$ and a complete Boolean algebra $\B$. A \textbf{$\B$-valued structure} is a type $M$ with realizations of all functions and relations in the language and a $\B$-valued congruence relation for equality. More precisely, it is an instance of the following structure:
  \begin{lstlisting}
structure bStructure (L : Language.{u}) :=
(carrier : Type u)
(fun_map {n} : L.functions n ‚Üí
    vector carrier n ‚Üí carrier)
(rel_map {n} : L.relations n ‚Üí
    vector carrier n ‚Üí ùîπ)
(eq : carrier ‚Üí carrier ‚Üí ùîπ)
(eq_refl (x) : eq x x = ‚ä§)
(eq_symm (x y) : eq x y = eq y x)
(eq_trans (x y z) : eq x y ‚äì eq y z ‚â§ eq x z)
(fun_congr {n} (f : L.functions n)
    (x y : vector carrier n) :
    ‚®Ö(map2 eq x y) ‚â§
    eq (fun_map f x) (fun_map f y))
(rel_congr {n} (R : L.relations n)
    (x y : vector carrier n) :
    ‚®Ö(map2 eq x y) ‚äì rel_map R x ‚â§
    rel_map R y)
\end{lstlisting}
Here ``\lstinline{‚®Ö(map2 eq x y)}'' means ``the infimum of the list whose $i$-th entry is \lil{eq (x[i]) (y[i])}''.
\end{defn}

Given a preterm \lil{t} in the language, we can realize it in any $\B$-valued structure $M$.
For this, we need to know the free variables in \lil{t}.
To do this conveniently with de Bruijn variables, we say that a (pre)term \lil{t} is \emph{bounded by \lil{l}} if all free variables are less than \lil{l} (i.e. all variables under \lil{k} quantifiers are less than \lil{k+l}).
Given \lil{t : preterm n} which is bounded by \lil{l}, and a realization \lil{v : vector M l} of the free variables, we define the realization $\llbracket t \rrbracket_M^v : M^n \to M$ by structural recursion on $t$.

For a formula $\varphi$ we do the same: we define bounded (pre)formulae, and define an realization $\llbracket \varphi \rrbracket_M^v : M^n \to \B$ by structural recursion.
If $\varphi$ is a sentence, the realization in a structure is just a element of the Boolean algebra: $\llbracket \varphi \rrbracket_M : \B$.

Since the truth values in a Boolean-valued model live inside the Boolean algebra $\B$ instead of just being true or false, we have to take a little care when stating the soundness theorem for Boolean-valued models.
Usually, a soundness theorem states something like ``if $\varphi$ is provable from hypotheses in $\Gamma$ then in every model where $\Gamma$ holds, $\varphi$ also holds.''
With Boolean truth-values, we need instead state it as an inequality of truth values. This motivates the following definition
\begin{defn}
We say that a set of sentences $\Gamma$ \emph{forces a sentence} $\varphi$, written $\Gamma \models_{\B}\varphi$, if for all non-empty $\B$-valued structures $M$ we have $\big(\bigsqcap_{\psi\in\Gamma}\big \llbracket \psi \rrbracket_M)\le\llbracket \varphi \rrbracket_M$.
\end{defn}
Using this definition, we can now state the Boolean-valued soundness theorem: \label{boolean-soundness}
\begin{lstlisting}
theorem boolean_soundness {Œì : set (sentence L)}
    {œï : sentence L} : Œì ‚ä¢ œï ‚Üí Œì ‚ä®[ùîπ] œï
\end{lstlisting}
The proof is a straightforward structural induction.

\section{Boolean-valued models of set theory}
\label{section:bset}
\subsection{The Aczel encoding}
\label{subsection:bset:aczel}
Our starting point is the Aczel encoding of \(\mathsf{ZFC}\) (\cite{aczel1978type, aczel1986type, aczel1982type}) into dependent type theory.
This was implemented in Coq by Werner \cite{werner1997sets}, and in Lean's \textsf{mathlib} by Carneiro \cite{mario1}.
The idea is to take a type universe \lstinline{Type u} and imitate the cumulative hierarchy construction with an inductive type:
\begin{lstlisting}
inductive pSet : Type (u+1)
| mk (Œ± : Type u) (A : Œ± ‚Üí pSet) : pSet
\end{lstlisting}
For an element \lil{x = ‚ü®Œ±, A‚ü© : pSet}, the function \lil{A} points to the elements of \lil{x}.
We can define the empty set as \lstinline{‚àÖ := ‚ü®empty, empty.elim‚ü© : pSet}.
Note that \lil{pSet} does not satisfy the axiom of extensionality.
In order to obtain a model where the axiom of extensionality holds, we must quotient \lstinline{pSet} by \emph{extensional equivalence} \lil{‚âà}.
We have to be a bit careful with defining extensional equivalence.
Although extensional equivalence and membership are easily defined in terms of each other,
one has to be careful to make sure the definition is well-founded.
\begin{lstlisting}
x ‚âà y ‚Üî ‚àÄw, w ‚àà x ‚Üî w ‚àà y
x ‚àà ‚ü®Œ±, A‚ü© ‚Üî ‚àÉa, x ‚âà A a
\end{lstlisting}
In order to make this well-founded, equivalence is defined by structural recursion:
\begin{lstlisting}
def equiv : pSet ‚Üí pSet ‚Üí Prop
| ‚ü®Œ±,A‚ü© ‚ü®Œ≤,B‚ü© := (‚àÄa, ‚àÉb, equiv (A a) (B b)) ‚àß
  (‚àÄb, ‚àÉa, equiv (A a) (B b))
\end{lstlisting}
We can now membership from equivalence and check that modulo extensional equivalence, \lstinline{pSet} is a model of \(\mathsf{ZFC}\).

% \paragraph{Two roads to \lstinline{bSet}}
% We describe two ways by which one can start at the ordinary model of \(\mathsf{ZFC}\) \lstinline{pSet} and end with a Boolean-valued model \lstinline{bSet}.

% First, note that we can construct a model of \(\mathsf{ZFC}\) roughly equivalent to \lstinline{pSet} as follows:
% \begin{lstlisting}
% inductive bSet : Type (u+1)
% | mk (Œ± : Type u) (A : Œ± ‚Üí bSet)
%   (B : Œ± ‚Üí bool): bSet
% \end{lstlisting}
% At first glance, \lstinline{bSet} adds large amounts of unnecessary information---while with \lstinline{pSet}, anything pointed to by an indexing function \lstinline{A} is a member of a set, \lstinline{bSet} only counts what is also assigned \lstinline{tt : bool}---and we can reconstruct \lstinline{pSet} from \lstinline{bSet} by recursively discarding anything which is assigned \lstinline{ff : bool} anyways. However, if we remember that \lstinline{bool} is a complete Boolean algebra \lstinline{‚ü®bool, ‚ä§, ‚ä•, ‚äì, ‚äî, ‚®Ö,‚®Ü, ‚üπ‚ü©}, then an upshot of the definition of \lstinline{bSet} is that we can replace the obvious analogue of \lstinline{equiv}
% \begin{lstlisting}
% def equiv : ‚àÄ (x y : bSet), Prop
% | ‚ü®Œ±,A,A'‚ü© ‚ü®Œ≤,B,B'‚ü© := (‚àÄ a : Œ±, A' a = tt ‚Üí ‚àÉ b : Œ≤, B' b = tt ‚àß equiv‚ÇÅ (A a) (B b)) ‚àß (‚àÄb : Œ≤, B' b = tt ‚Üí ‚àÉ a : Œ±, A' a = tt ‚àß equiv‚ÇÅ (A a) (B b))
% \end{lstlisting}
% with a version which avoids propositional operations and only uses the operations of a complete Boolean algebra:\footnote{Assuming \lstinline{Prop ‚âÉ bool}, which is provable using classical logic in Lean.}
% \begin{lstlisting}
% def equiv‚ÇÇ : ‚àÄ (x y : bSet), bool
% | ‚ü®Œ±,A,A'‚ü© ‚ü®Œ≤,B,B'‚ü© := ‚®Ö a : Œ±, A' a ‚üπ ‚®Ü b : Œ≤, B' b ‚äì equiv‚ÇÇ (A a) (B b) ‚äì  ‚®Ö b : Œ≤, B' b ‚üπ ‚®Ü a : Œ±, A' a ‚äì equiv‚ÇÇ (A a) (B b)
% \end{lstlisting}
% Since this definition only interfaces with the typeclass of complete Boolean algebras, we can replace \lstinline{bool} by an arbitrary complete Boolean algebra \lstinline{ùîπ} throughout, yielding: % note(jesse, October 03 2019, 05:06 PM): maybe should emphasize definition of membership instead of equality to make it clear that these things are Boolean-valued models of ZFC
% \begin{lstlisting}
% inductive bSet (ùîπ : Type u) [complete_boolean_algebra ùîπ]: Type (u+1)
% | mk (Œ± : Type u) (A : Œ± ‚Üí bSet)
%   (B : Œ± ‚Üí ùîπ): bSet
% \end{lstlisting}
% which we later verify is a \(\mathbb{B}\)-valued model of \(\ZFC\).

\subsection{Boolean-valued sets}
\label{subsection:bset:bset}
We now want to generalize \lil{pSet} to a Boolean-valued model of \(\ZFC\). In order to do this, we need to give a
\(\B\)-valued relation that corresponds to membership \lil{‚àà}. We encode this information, by adding an extra field to elements of \lil{pSet}, which is a \(\B\)-valued predicate.
\begin{lstlisting}
inductive bSet (ùîπ : Type u)
    [complete_boolean_algebra ùîπ] : Type (u+1)
| mk (Œ± : Type u) (A : Œ± ‚Üí bSet)
    (B : Œ± ‚Üí ùîπ) : bSet
\end{lstlisting}
The predicate \lil{B} expresses that \lil{A a ‚àà ‚ü®Œ±, A, B‚ü©} has truth value (at least) \lil{B i}.

This is closely related to the recursive \emph{name}-construction from forcing, a key ingredient to building forcing extensions. Let \(\mathbb{P}\) be a poset. From e.g.\ Kunen \cite{kunen2014set}, Definition IV.2.5:
\begin{defn}
  A set \(\tau\) is a \(\mathbb{P}\)-name iff \(\tau\) is a relation and for all \(\langle  \sigma, p\rangle \in \tau\) we have that \(\sigma\) is a \(\mathbb{P}\)-name and \(p \in \mathbb{P}\).
\end{defn}
\lstinline{bSet ùîπ} should be thought of as the type of \lstinline{ùîπ}-names, where the relation of \lil{‚ü®Œ±, A, B‚ü©} is given by \lstinline"{ ‚ü®A i, B i‚ü© | i ‚àà Œ± }".
The definitions are not exactly the same, as \lil{A} need not be injective, but we can define the same operations on \lil{bSet ùîπ} as on \lil{ùîπ}-names.

% In particular, if \(\mathbb{P}\) is the singleton poset, then a \(\mathbb{P}\)-name is a set of \(\mathbb{P}\)-names, in the same way that a term of type \lstinline{pSet} is a type-indexed collection of terms of type \lstinline{pSet}.
% Reversing this observation, we replace \(\mathbb{P}\) with a complete Boolean algebra \(\mathbb{B}\) and generalize the definition of \lstinline{pSet.mk} with a third field, so that as in the case of \(\mathbb{P}\)-names, every element of a set is assigned an element (a ``Boolean truth-value'') of \(\mathbb{B}\):
% \begin{lstlisting}
% inductive bSet {ùîπ : Type u) : Type (u+1)
% | mk (Œ±: Type u) (A: Œ± ‚Üí bSet) (B: Œ± ‚Üí ùîπ) : bSet
% \end{lstlisting}
% Whatever is important in \lstinline{bvm}, \lstinline{bvm_extras}, \lstinline{bvm_extras2} for this argument.

% \subsection{Boolean-valued equality and membership}
We can define Boolean-valued equality and membership analogously to the definitions in \lil{pSet}.
To do this, we have to translating quantifiers and connectives into operations on $\B$:
\begin{lstlisting}
def bv_eq : bSet ùîπ ‚Üí bSet ùîπ ‚Üí ùîπ
| ‚ü®Œ±, A, B‚ü© ‚ü®Œ±', A', B'‚ü© :=
  (‚®Öa, B a ‚üπ ‚®Üa', B' a' ‚äì bv_eq (A a) (A' a')) ‚äì
  (‚®Öa', B' a' ‚üπ ‚®Üa, B a ‚äì bv_eq (A a) (A' a'))
\end{lstlisting}
We abbreviate \lil{bv_eq} with the infix operator \lil{=·¥Æ}.
It is now easy to define $\B$-valued membership, which we denote by \lil{‚àà·¥Æ}.
\begin{lstlisting}
def mem : bSet ùîπ ‚Üí bSet ùîπ ‚Üí ùîπ
| x ‚ü®Œ±, A, B‚ü© := ‚®Üa, B a ‚äì x =·¥Æ A a
\end{lstlisting}
\subsection{The fundamental theorem of forcing}
\label{subsection:bset:fundamental-thm}
The fundamental theorem of forcing for Boolean-valued models~\cite{hamkins2012well} states that for any complete Boolean algebra \lil{ùîπ}, the type \lil{bSet ùîπ} forms a Boolean-valued model of $\mathsf{ZFC}$.

Bell~\cite{bell2011set} gives an extremely detailed account of the verification of the $\mathsf{ZFC}$ axioms,
and we faithfully followed his presentation for this part of the formalization.
Although most of the argument is routine, we describe some aspects of \lil{bSet ùîπ} which are revealed by this verification.

We can define subsets of a set $x$ by just modifying the last component of $x$.
This gives a nice definition of powerset:
\begin{defn} \label{def-powerset}
  Fix a $\B$-valued set \lil{x = ‚ü®Œ±, A, b‚ü©} and \lil{œá : Œ± ‚Üí ùîπ} be a function.
  We can define the $\B$-valued set $\tilde{\chi}$ as \lil{‚ü®Œ±, A, œá‚ü©}.
  The \textbf{powerset} $\mathcal{P}(x)$ of $x$ is defined to be the \lil{ùîπ}-valued set
  \[\langle \alpha \to \B, (\lambda\; \chi, \widetilde{\chi}),\ (\lambda\;\chi, \tilde{\chi} \subseteq^B x)\rangle.\]
\end{defn}

In particular, this gives an easy proof of the axiom of comprehension (not just for interpretations of formulas, but for any \(\mathbb{B}\)-valued predicate on \lil{bSet ùîπ} satisfying an appropriate \(\mathbb{B}\)-valued congruence lemma):

%TODO(jesse): add axiom of comprehension

% \subparagraph*{The axiom of infinity}
% \lil{œâ : pSet} is defined to be the collection of all finite von Neumann ordinals (via induction on $\mathbb{N}$), and we define \lil{œâ : bSet ùîπ} as \(\widecheck{\omega}\).
% Now \lil{œâ} is the $\subseteq$-least set that contains $\varnothing$ and is closed under the successor operation $x \mapsto x \cup \{x\}$.
% More generally, we define a map \lil{ordinal.mk : ordinal ‚Üí pSet} by transfinite recursion.

% \subparagraph*{The axiom of powerset}

% \subparagraph*{The axiom of choice}
Following Bell, we verified Zorn's lemma in \lil{bSet ùîπ}.
As is the case with \lil{pSet}, establishing Zorn's lemma requires the use of a choice principle from the metatheory.
This was the most involved part of our verification of the fundamental theorem of forcing, and relies on the technical tool of \emph{mixtures}, which allow sequences of $\B$-valued sets to be ``averaged'' into new ones.
It also uses the \emph{maximum principle}, which allows existentially quantified statements to be instantiated without changing their truth-value. % TODO: expand, if we have room

% \subparagraph*{The smallness of \ $\B$}
% We end this section by remarking that the ``smallness'' of $\B$ (or more precisely, the fact that $\B$ lives in the same universe of types out of which \lil{bSet ùîπ} is being built) is essential in making \lstinline{bSet ùîπ} a model of $\mathsf{ZFC}$.
% It is required for extracting the witness needed for the maximum principle, and is also required to even define the powerset operation, because the underlying type of the powerset is the function type of all maps into \lstinline{ùîπ}.

% \subparagraph*{Check-names}
\begin{defn}\label{def-check}
  We define the canonical map \lil{check : pSet ‚Üí bSet ùîπ} by
  \begin{lstlisting}
  def check : pSet ‚Üí bSet ùîπ
  | ‚ü®Œ±,A‚ü© := ‚ü®Œ±, check ‚àò A, (Œª a, ‚ä§)‚ü©
  \end{lstlisting}
  We also write $\widecheck{x}$ for \lil{check x}, and call it a \emph{check-name}.
  % We call members of the image of \lil{check} \emph{check-names}, %\footnote{This terminology is standard, c.f. \cite{hamkins2012well, moore2019method}.}
  These are also known as \emph{canonical names}, as they are the canonical representation of standard two-valued sets inside a Boolean-valued model of set theory.\footnote{We were pleased to discover Lean's support for custom notation allowed us to declare the Unicode modifier character \texttt{U+030C} ($\widecheck{\hspace{1mm}}$) as a postfix operator for \texttt{check}.}
\end{defn}

% \subparagraph*{ordinals in $\B$}

% TODO(jesse): fix this
To define ordinals, we can define a map \lil{ordinal.mk : ordinal ‚Üí pSet} by transfinite recursion.
If we compose this map with \lil{check} we get the ordinals in \lil{bSet ùîπ}.
In particular, we get the least infinite ordinal \lil{œâ : bSet ùîπ}, which witnesses the axiom of infinity.
% \lil{œâ : pSet} is defined to be the collection of all finite von Neumann ordinals (via induction on $\mathbb{N}$), and we define \lil{œâ : bSet ùîπ} as \(\widecheck{\omega}\).
% Now \lil{œâ} is the $\subseteq$-least set that contains $\varnothing$ and is closed under the successor operation $x \mapsto x \cup \{x\}$.


We summarize the relationship between the three ``large'' types currently in play:
\[
  \begin{tikzcd}
    % & \text{\lstinline{Type u+1}} & & \\
    \texttt{pSet} \arrow{rr}{\texttt{check}} & & \texttt{bSet } \mathbb{B} & \\
    & & & \\
    \texttt{ordinal.\{u\}} \arrow{uu}{\texttt{ordinal.mk}} \arrow{uurr} & & & % \\
    % \hspace{0mm}  \arrow[dashed, no head]{rrr } & & & \hspace{0mm} \\
    % & \mathbb{B} & & \\
    % & \text{\lstinline{Type u}} & &
  \end{tikzcd}
\]

We spell out the name of Lean ordinals and cardinals, and use (checked) Hebrew letters for their (Boolean-valued) set-theoretic counterparts, so that with respect to the above diagram, we have:
\[
  \begin{tikzcd}
    % & \text{\lstinline{Type u+1}} & & \\
    \aleph_1 \arrow[mapsto]{rr}{\texttt{check}} & & \widecheck{\aleph_1} & \\
    & & & \\
    \text{\lstinline{(aleph 1)}} \arrow[mapsto]{uu}{\texttt{ordinal.mk}} \arrow[mapsto]{uurr} & & & % \\
    % \hspace{0mm}  \arrow[dashed, no head]{rrr } & & & \hspace{0mm} \\
    % & \mathbb{B} & & \\
    % & \text{\lstinline{Type u}} & &
  \end{tikzcd}
\]

Since in general, \(\widecheck{\aleph_1}\) is \emph{not} what \lil{bSet ùîπ} thinks is \(\aleph_1\), we will use a superscript, e.g. \(\aleph_k^{\mathbb{B}}\), to denote the internal alephs of \lil{bSet ùîπ}.


% TODO(jesse): add a note in the introduction on how Dana Scott was the first one to point out that the names could be taken at face value as a model of ZFC if one was willing to shift to a many-valued logic instead.


\section{Forcing} \label{section:forcing}
Our point of departure from conventional accounts of forcing with a poset \(\mathbb{P}\) over a countable transitive model \cite{kunen2014set, jech2013set}, which use a generic filter to ``evaluate'' the \lstinline{‚Ñô}-names to produce an ordinary model of \(\ZFC\), is to force with \emph{Boolean-valued models} of \(\ZFC\) instead.
As first observed by Scott and Solovay \cite{scott-solovay}, this obviates the need for countable transitive models, generic filters, or the truth and definability lemmas, and allows us to work only with the \lstinline{ùîπ}-names.
% Comment: this would be much better in the introduction: we need to motivate why we use boolean valued models.

The cost of taking the \lstinline{ùîπ}-names at face value is that the calculus of the forcing relation \cite{shoenfield1971unramified}, a key technical tool in usual forcing arguments, is replaced by the calculation of Boolean truth-values in \lstinline{ùîπ}.
From the Boolean-valued perspective, forcing a sentence \(\Phi\) in the language of \(\mathsf{ZFC}\) means constructing some Boolean algebra \lil{ùîπ} and a \lil{ùîπ}-valued model \(M\) of \(\ZFC\) such that the truth value \(\Phi^{M}\) of \(\Phi\) is \(\top\).
We will always force over a type universe \lil{Type u}, and our Boolean-valued models of \(\mathsf{ZFC}\) are always of the form \lil{bSet ùîπ} for some \lil{ùîπ : Type u}.
That \lil{ùîπ} belongs to {Type u} is crucial for forcing, as specific choices of \lil{ùîπ} will affect the structure of \lil{bSet ùîπ} (and hence the truth-value of \(\Phi\)). % However, the effects of a particular choice of \lil{ùîπ} is often only easily determined on the check-names, and a deeper combinatorial analysis of \lil{ùîπ} is required to complete the argument.

In this section, we describe two forcing arguments, one for \(\neg \CH\) and another for \(\CH\).
Both follow roughly the same pattern. In both cases, we require the existence of a function; for \(\neg \CH\), an injection \(\aleph_2 \hookrightarrow \mathcal{P}(\omega)\), and for \(\CH\), a surjection \(\aleph_1 \twoheadrightarrow \mathcal{P}(\omega)\).
We will construct a Boolean algebra \lil{ùîπ} which encodes the construction (in \lil{Type u}) of such a function \(F\).
Then \lil{ùîπ} induces in \lil{bSet ùîπ} an approximation \(\widetilde{F}\) to such a function, which \emph{a priori} is only between check-names.
To finish the forcing argument, we must show that it suffices to work with \(\widetilde{F}\).
This requires a careful study of how truth-values are calculated in \lil{bSet ùîπ},
and ultimately reduces to an analysis of how truth-values of \(\forall\)-\(\exists\) statements in \lil{bSet ùîπ} can be reflected \emph{back} to \lil{Type u}, and verifying a combinatorial condition on \lil{ùîπ}.

\subsection{Regular open algebras}
\begin{defn}\label{def-regular-open-algebra}
  Let $X$ be a topological space, and for any open set $U$, let $U^{\perp}$ denote the complement of the closure of $U$.
  The \textbf{regular open algebra} of a topological space $X$, written $\operatorname{RO}(X)$, is the collection of all open sets $U$ such that $U = (U^\perp)^\perp$, or equivalently such that
  $U$ is equal to the interior of the closure of $U$.
  $\operatorname{RO}(X)$ is equipped with the structure of a complete Boolean algebra, with $x \sqcap y := x \cap y$ and $x \sqcup y := ((x \cup y)^\perp)^\perp$ and $\neg x := x^\perp$ and $\bigsqcup x_i := ((\bigcup x_i)^\perp)^\perp$.
\end{defn}

While forcing conditions usually present themselves as a poset instead of a complete Boolean algebra, any forcing poset can be represented as the dense suborder of a regular open algebra \cite{moore2019method}.

\begin{defn}\label{def-dense-suborder}
  A \textbf{dense suborder} of \(\B\) is a subset \(\mathbb{P} \subseteq \B\) satisfying the following conditions: (1) for all \(p \in \mathbb{P}\), \(\bot < p\); (2) for all \(\bot < b \in \B\), there exists a \(p \in \mathbb{P}\) such that \(p \leq b\).
\end{defn}

We will use the following combinatorial conditions on \(\mathbb{B}\) in our forcing arguments:

\begin{defn}\label{def-ccc}
We say that $\B$ has the \textbf{countable chain condition} (CCC) if every antichain $\mathcal{A} : I \to \B$ (i.e. an indexed collection of elements $\mathcal{A} := \{a_i\}$ such that whenever $i \neq j, a_i \sqcap a_j = \bot$) has a countable image.
\end{defn}

\begin{defn}\label{def-sigma-closed}
We say that \(\B\) is \textbf{\(\sigma\)-closed} if there exists a dense suborder \(\mathbb{P}\) of \(\B\) such that every \(\omega\)-indexed downwards chain \(p_0 \geq p_1 \geq \cdots \geq p_n \cdots\) in \(\mathbb{P}\) has a lower bound \(p_{\omega}\) in \(\mathbb{P}\).
\end{defn}

\subsection{Cohen forcing}

As we have already seen in Definition~\Cref{def-powerset}, we construct the powerset of a \lil{ùîπ}-valued set \lstinline{u : bSet ùîπ} using \lil{ùîπ}-valued indicator functions \lil{œá : u.type ‚Üí ùîπ}.
The basic strategy of Cohen forcing is to choose \lil{ùîπ} such that for every \(\nu : \aleph_2\), there is a canonical indicator function (a ``Cohen real'') \(\chi_{\nu} : \omega \to \mathbb{B}\).
This is an external function (a member of a function type of \lstinline{Type u}) which we check descends to an injective function \(\widecheck{\aleph_2} \to \mathcal{P}(\omega)\) in \lil{bSet ùîπ}.
To show that this injection suffices to negate \(\CH\), we show that if \lil{ùîπ} satisfies the CCC, then \(\omega \prec \widecheck{\aleph_1} \prec \widecheck{\aleph_2} \preceq \mathcal{P}(\omega)\),
and ensure that our choice of \lil{ùîπ} has this property.

\begin{defn}
  The \textbf{Cohen poset} for adding $\aleph_2$-many Cohen reals is the collection of all finite partial functions $\aleph_2 \times \mathbb{N} \to \mathbf{2}$, ordered by reverse inclusion.
\end{defn}

In the formalization, the Cohen poset is represented as a \lstinline{structure} with three fields:
\begin{lstlisting}
structure ‚Ñô_cohen : Type :=
  (ins : finset (‚Ñµ‚ÇÇ.type √ó ‚Ñï))
  (out : finset (‚Ñµ‚ÇÇ.type √ó ‚Ñï))
  (H : ins ‚à© out = ‚àÖ)
\end{lstlisting}
%TODO(jesse): reword
That is, we identify a finite partial function $f$ with the triple \lil{‚ü®f.ins, f.out, f.H‚ü©}, where \lil{f.ins} is the preimage of $\{1\}$, \lil{f.out} is the preimage of $\{0\}$, and \lil{f.H} ensures well-definedness.
While $f$ is usually defined as a finite partial function, we found that in practice $f$ is really only needed to give a finite partial specification of a subset of $\aleph_2 \times \mathbb{N}$ (i.e. a finite set \lil{f.ins} which \emph{must} be in the subset,
and a finite set \lil{f.out} which \emph{must not} be in the subset), and chose this representation to make that information immediately accessible.

The Boolean algebra which we will use for forcing $\neg\mathsf{CH}$ is \lil{ùîπ_cohen := } $\operatorname{RO}(2^{\aleph_2 \times \mathbb{N}})$, where we equip $2^{\aleph_2 \times \mathbb{N}}$ with the usual product space topology.

\begin{defn}
  We define the \textbf{canonical embedding} of the Cohen poset into \lil{ùîπ_cohen} as follows:
  \begin{lstlisting}
def Œπ : ‚Ñô_cohen ‚Üí ùîπ_cohen := Œª p, {S | p.ins ‚äÜ S ‚àß p.out ‚äÜ - S}
\end{lstlisting}
\end{defn}
That is, we send each \lil{c : ùíû} to all the subsets which satisfy the specification given by \lil{c}. This is a clopen set, hence regular.
Crucially, the image of this embedding is a dense suborder of \lil{ùîπ_cohen}.
Recalling that $\leq$ in $\B$ is subset-inclusion, we see that this is essentially because the image of $\iota : \mathcal{C} \to \B$ \emph{is} the standard basis for the product topology.
Our chosen encoding of the Cohen poset also made it easier to perform this identification when formalizing this proof.

\begin{lemma}\label{lemma-cohen-algebra-CCC}
  \lil{ùîπ_cohen} has the CCC.
\end{lemma}

\begin{proof}
  TODO(floris)
\end{proof}

\begin{defn}
  Let $\nu : \aleph_2$. For any $n : \N$, the collection of all subsets of $\aleph_2 \times \N$ which contain $(\nu, n)$ is a regular open of $2^{\aleph_2 \times \N}$, called the \textbf{principal open} $\mathbf{P}_{(\nu, n)}$ over $(\nu, n)$.
\end{defn}

\begin{defn}
  Let $\nu : \aleph_2$. We associate to $\nu$ the $\B$-valued characteristic function $\chi_{\nu} : \N \to \B$ defined by $\chi_{\nu}(n) := \mathbf{P}_{(\nu, n)}$.
  In light of our previous observations, we see that each $\chi_{\nu}$ induces a new $\B$-valued subset $\widetilde{\chi_{\nu}} \subseteq \widecheck{\N}$. We call $\widetilde{\chi_{\nu}}$ a \textbf{Cohen real}.
\end{defn}
This gives us an $\aleph_2$-indexed family of Cohen reals. Converting this data into an injective function from \(\widecheck{\aleph_2}\) to $\mathcal{P}(\mathbb{N})$ inside \lil{bSet ùîπ} requires some care.
One must check that $\nu \mapsto \widetilde{\chi_{\nu}}$ is externally injective, and this is where the characterization of the Cohen poset as a dense subset of $\B$ (and moving back and forth between this representation and the definition as finite partial functions) comes in.
Furthermore, one has to develop machinery similar to that for the powerset operation to convert an external injective function \lstinline{x.type ‚Üí bSet ùîπ} to an internal injective function in \lstinline{bSet ùîπ}.
% Our custom tactics and automation for reasoning inside $\B$ made this latter task significantly easier than it would have been otherwise. We refer the interested reader to our formalization for details.

By definition, our newly-constructed injection gives that \(\widecheck{\aleph_2} \preceq \mathcal{P}(\omega)\).
To finish negating \(\mathsf{CH}\), it suffices to show that there exist some \lil{y : bSet ùîπ} such that \lil{œâ ‚â∫ y ‚â∫ ‚Ñµ‚ÇÇÃå  ‚âº ùí´(œâ)}.
Taking \(y\) to be \(\widecheck{\aleph_1}\), it suffices to show that in \lil{bSet ùîπ}, there is no surjection \(\widecheck{\aleph_1} \twoheadrightarrow \widecheck{\aleph_2}\).

The strategy of the proof is to assume that there is a surjection \(\widecheck{\aleph_1} \twoheadrightarrow \widecheck{\aleph_2}\).
Thus surjectivity assumption is a Boolean-valued \(\forall\)-\(\exists\) statement about check-names, and we will \emph{reflect} it into the metatheory, producing a \(\forall\)-\(\exists\) statement about the non-checked counterparts in \lil{pSet}.
We will then use a combinatorial condition on \lil{ùîπ_cohen} (in this case, the CCC) to show that the reflected \(\forall\)-\(\exists\) statement implies a contradiction.

Specifically, we use the following lemma, which is true for general \(\mathbb{B}\):
\begin{lstlisting}
lemma AE_of_check_larger_than_check {x y : pSet (f : bSet ùîπ) {Œì : ùîπ} (H_nonzero : ‚ä• < Œì)
  (H : Œì ‚â§ is_surj_onto xÃå yÃå f) (H_nonempty : ‚àÉ z, z ‚àà y) : ‚àÄ i : y.type, ‚àÉ j : x.type, ‚ä• < (is_func f) ‚äì (pair (x.func j)Ãå  (y.func i)Ãå  ‚àà·¥Æ f)
\end{lstlisting}
Suppose that there is a surjection \(\widecheck{\aleph_1} \twoheadrightarrow \widecheck{\aleph_2}\).
Applying this lemma to \(x := \widecheck{\aleph_1}\), \(y := \widecheck{\aleph_2}\), we obtain a \(\forall\)-\(\exists\) statement in the metatheory to which we can apply Lean's axiom of choice to produce a function \(g : \aleph_2 \to \aleph_1\).
Since externally, we know that \(\aleph_1 \prec \aleph_2\), it follows from the infinite pigeonhole principle that \(g\) must have an uncountable fiber over some \(\nu < \aleph_1\).
For every \(\eta \in g^{-1}(\{\nu\})\), let \(A_{\eta}\) be the element of \lil{ùîπ_cohen} given by the lemma, i.e.
\[A_{\eta} := \text{\lil{(is_func f) ‚äì (pair (‚Ñµ‚ÇÅ.func ŒΩ)Ãå  (‚Ñµ‚ÇÇ.func Œ∑)Ãå  ‚àà·¥Æ f)}}\]

Because each \(A_{\eta}\) carries around the knowledge that \(f\) is a function as a conjunct, for \(\eta_1 \neq \eta_2\), \(A_{\eta_1}\) and \(A_{\eta_2}\) are incompatible, i.e. \(A_{\eta_1} \sqcap A_{\eta_2} = \bot\).
Since the lemma guarantees that each \(A_{\eta}\) is nonzero, the \(A_{\eta}\) form an uncountable antichain.
Therefore, if \(\mathbb{B}\) has the CCC, there is a contradiction, so by \Cref{lemma-cohen-algebra-CCC}, we have forced \(\neg\mathsf{CH}\) in \lil{bSet ùîπ_cohen}.

\subsection{Collapse forcing} \label{subsection:collapse}
% note(jesse, October 01 2019, 04:11 PM): i think levy collapse only involves the collapse of strongly inaccessible cardinals, and that the collapsing argument we use goes by the name of œÉ-closed, œâ-closed, countably closed forcing or maybe just collapse forcing? we should clarify this.

Whereas Cohen forcing creates a new injection \(\widecheck{\aleph_2} \hookrightarrow \mathcal{P}(\omega)\), we can use \emph{collapse forcing} to create a new surjection \(F : \aleph_1^{\mathbb{B}} \twoheadrightarrow \mathcal{P}(\omega)\).
Similarly to Cohen forcing, the strategy is to pick \lil{ùîπ} such that there is a canonical \lil{ùîπ}-valued indicator function on \(\widecheck{\aleph_1} \times \widecheck{\mathcal{P}(\omega)}\) representing the graph of a surjection \(\widetilde{F}\).
To show that \(\widetilde{F}\) suffices to force \(\CH\), we must show that \(\widecheck{\aleph_1} = \aleph_1^{\mathbb{B}}\), and that \(\widecheck{\mathcal{P}(\omega)} = \mathcal{P}(\omega).\)
Both equalities follow from being able to lift functions \(\omega \to \widecheck{y}\) to functions \(\omega \to y\);
this will follow from ensuring our choice of \(\mathbb{B}\) is \(\sigma\)-closed (\Cref{def-sigma-closed}).

\begin{defn}\label{def-collapse-poset}
  We define \lstinline{‚Ñô_collapse} to be the poset of countable partial functions \(\aleph_1 \to \mathcal{P}(\omega)\). The principal open sets \[D_p := \{g : \aleph_1 \to \mathcal{P}(\omega) \hspace{2mm} | \hspace{2mm} g \text{ extends } p\} , \hspace{3mm} p \in \mathbb{P}_{\text{collapse}}\] form the basis of a topology \(\tau\) (finer than the product topology) on the function set \(\mathcal{P}(\omega)^{\aleph_1}\). We put
  \begin{center}
  \lstinline{ùîπ_collapse :=} \(\operatorname{RO}\left(\mathcal{P}(\omega)^{\aleph_1}, \tau\right)\).
  \end{center}
\end{defn}

\begin{lemma}\label{lemma-collapse-algebra-sigma-closed}
  % Note to Floris: currently, sigma-closed is defined to be a property of complete Boolean algebras, namely that they possess a sigma-closed (in the usual sense) dense suborder
  \lil{ùîπ_collapse} is \(\sigma\)-closed.
\end{lemma}

\begin{proof}
  TODO(floris)
\end{proof}

\begin{remark}
  As an implementation detail, in the formalization we \emph{define} \lil{‚Ñô_collapse} to be the countable partial functions (in \lil{Type u}) between \lil{(ordinal.mk (aleph one) : pSet).type} and \lil{(powerset omega : pSet).type}, so that \\ \lil{ùîπ_collapse}-valued indicator functions on \lil{ordinal.mk (aleph one) : pSet).type √ó (powerset omega : pSet).type} are definitionally equal to \lil{ùîπ_collapse}-valued indicator functions on the underlying types of \lil{check (ordinal.mk (aleph one))} and \lil{check (powerset omega)}.
\end{remark}

To specify the surjection \(\widecheck{\aleph_1} \twoheadrightarrow \widecheck{\mathcal{P}(\omega)}\), we specify a subset (the graph of the function) of the powerset \(\mathcal{P}(\widecheck{\aleph_1} \times \widecheck{\mathcal{P}(\omega)})\).
In \lil{bSet ùîπ_collapse}, we can do this by specifying the indicator function \(\chi_{\pi}\) of the graph of a function \(\pi : \widecheck{\aleph_1} \to \widecheck{\mathcal{P}(\omega)}\) as follows: to an \(\eta < \aleph_1\) and a subset \(S \subseteq \mathcal{P}(\omega)\) (in \lil{pSet}), we attach the \emph{principal open} (comprising functions extending the singleton countable partial function \(\{(\eta, S)\}\)):
\[
  \chi_\pi (\eta, S) := D_{\{(\eta, S)\}} = \{g : \aleph_1 \to \mathcal{P}(\omega) \operatorname{|} g (\eta) = S\}.
\]

More generally, we formalize conditions over generic \lil{x, y : pSet} and \lil{ùîπ} for when a function \lil{af : x.type ‚Üí y.type ‚Üí ùîπ} induces a surjection \(\widecheck{x} \to \widecheck{y}\) in \lil{bSet ùîπ}.
By definition, such a function always induces a relation on the product (in \lil{bSet ùîπ}) of \lil{x} and \lil{y}.
Surjectivity is equivalent to \lil{‚®Ö j, (‚®Ü i, af i j) = ‚ä§}, totality is equivalent to \lil{‚®Ö i, (‚®Ü j, af i j) = ‚ä§}, and well-definedness follow from the following two conditions:
\begin{lstlisting}
(H_anti : ‚àÄ i, ‚àÄ j‚ÇÅ j‚ÇÇ, j‚ÇÅ ‚â† j‚ÇÇ ‚Üí af i j‚ÇÅ ‚äì af i j‚ÇÇ ‚â§ ‚ä•)
(H_inj : ‚àÄ i‚ÇÅ i‚ÇÇ, ‚ä• < (func x i‚ÇÅ) =·¥Æ (func x i‚ÇÇ) ‚Üí i‚ÇÅ = i‚ÇÇ)
\end{lstlisting}
Both surjectivity and totality of \(\chi_{\pi}\) require \emph{denseness arguments}, where the definition of indexed supremum (\(\bigsqcup x_i\)) in the regular open algebra as the regularization \(((\bigcup x_i)^\perp)^\perp\) of the set-theoretic union plays a key role: the union of the truth values is not the entire space, but is only a dense open whose regularization is the entire space. In particular, the denseness argument for surjectivity crucially uses that \(\aleph_1\) is uncountable while \(\omega\) is countable.

To finish demonstrating that \(\CH\) is true in \lil{bSet ùîπ_collapse}, it remains to check that \(\widecheck{\mathcal{P}(\omega)} = \mathcal{P}(\omega)\) and \(\widecheck{\aleph_1} = \aleph_1\).
There are two major obstacles. The first is that to even formally state the latter equality, we must construct \(\aleph_1^{\mathbb{B}}\) in \lil{bSet ùîπ}.
(While the operation \lil{bv_powerset} (\Cref{def-bv-powerset}) gives a construction of the internal powerset of any \lil{x : bSet ùîπ} (using \lil{ùîπ}-valued indicator functions, for any \lil{ùîπ}), \(\aleph_1^{\mathbb{B}}\) is only specified as the least ordinal greater than \(\omega\), and does not admit as direct a a construction.)
We describe our construction of \(\aleph_1^{\mathbb{B}}\) (as the Hartogs number of \(\omega\)) in \Cref{subsection:forcing:aleph-1}.

Now we must ensure that no new countable ordinals are added to \(\aleph_1\) and that no new subset of \(\omega\) are added to \(\mathcal{P}(\omega)\) in the passage via \lil{check} from \lil{pSet} to \lil{bSet}. The second obstacle is reducing both statements to, and proving, the following lemma:

\begin{lemma}\label{lemma-function-reflect-suffices}
  Let \(\mathbb{B}\) be a complete Boolean algebra, and suppose that for every \lil{y : pSet}, and every \lil{f : bSet ùîπ} such that \lil{bSet ùîπ} models that \lil{f} is a function from \(\omega\) to \(\widecheck{y}\), there exists a \lil{g : pSet} such that \lil{g} is a function from \(\omega\) to \lil{y} in \lil{pSet}, and \lil{bSet ùîπ} models that \(\widecheck{g} = f\).
  Then \(\widecheck{\mathcal{P}(\omega)} = \mathcal{P}(\omega)\) and \(\widecheck{\aleph_1} = \aleph_1^{\mathbb{B}}\).
\end{lemma}

We describe our solution to this in \Cref{subsect:function-reflection}.




% As with Cohen forcing, we will proceed by using \(\forall\)-\(\exists\) reflection to reflect functions from \(\omega\) to check-names back into \lil{pSet}, and then showing that the two required equalities follow from this.

\subsection{Construction of $\aleph_1$} \label{subsection:forcing:aleph-1}
Instead of using the specification of \(\aleph_1^{\mathbb{B}}\) as the least ordinal larger than \(\omega\) with Cantor's theorem and using the well-foundedness of the ordinals to construct \(\aleph_1\),
we opt for a direct construction of \(\aleph_1\), based on the well-known construction of \(\aleph_1\) as the \textbf{Hartogs number} of \(\omega\) \cite{hartogs1915problem}.

% TODO: summarize the construction of the Hartogs number

We lay out the basic strategy.
Recall that a term of type \lil{bSet ùîπ} comprises three pieces of information: an indexing type \(\alpha\), an indexing function \lil{A : Œ± ‚Üí bSet ùîπ}, and a truth-value function \lil{B : Œ± ‚Üí ùîπ}.
\begin{enumerate}
\item We \emph{define} the underlying type \(\alpha\) for \(\aleph_1^{\mathbb{B}}\) to be \lil{ùí´(œâ √ó œâ).type}.
\item We define the truth-value function \lil{B : Œ± ‚Üí ùîπ} to assign to any \(R \subseteq \omega \times \omega\) the (truth-value of) the sentence,
``there exists an ordinal \(\eta\) and an injection \(f : \eta \hookrightarrow \omega\) such that \(R\) is the image of the membership relation of \(\eta\) under \(f\).''

\item Using the maximum principle (which is essentially \(\mathsf{AC}\)), we define the indexing function \(A\) for \(\aleph_1^{\mathbb{B}}\) by choosing, for every \(R : \alpha\), a witness \(\eta_R\) such that \(R\) is the image of \(\eta\) under an injection into \(\omega\).
That \(A\) surjects onto countable ordinals reduces to the fact that order-isomorphic ordinals must be equal.
\end{enumerate}

\paragraph{Implementation details}
In the formalization, this strategy is implemented in three stages.
First, the axiom of comprehension is applied to \(\mathcal{P}(\omega \times \omega)\) to produce (what \lil{bSet ùîπ} thinks is) the collection of all relations \(R\) on \(\omega\) such that there exists an ordinal \(\eta\) and an injection \(f : \eta \hookrightarrow \omega\) such that \(R\) is the image of \(\eta\)'s membership relation under \(f\).
This combines steps \(1\) and \(2\) and produces a set \lil{a1'_aux}. Then we \emph{modify} the indexing function \lil{a1'_aux.func} (by using the maximum principle, as described in step \(3\)) to point from \(R\) to a chosen witness \(\eta_R\) for \(R\), producing \lil{a1'}.
Finally, since the ordinals \(0\) and \(1\) both have empty membership relations, it is unprovable in Lean whether \lil{a1'} contains one or the other, so we add both manually, producing \lil{a1 :=} \(\aleph_1^{\mathbb{B}}\).
We remark that our construction does not use specific properties of \(\omega\) and easily generalizes to construct the successor cardinal of any infinite set.

% TODO(jesse): maybe describe the interesting technical caveat about why external choice on the indexing types is not enough to finish the construction

\subsection{Function reflection} \label{subsect:function-reflection}

\begin{proof}[Proof of \Cref{lemma-function-reflect-suffices}.]
  % Observe that by definition of \(\aleph_1\), we have that for every ordinal \(\eta\), \(\eta < \aleph_1\) if and only if there exists a surjection \(\omega \twoheadrightarrow \eta\) (equivalently, there is an injection \(\eta \hookrightarrow \omega\)). Also, \(\mathcal{P}(\omega) \simeq \widecheck{2}^{\widecheck{\omega}}\) (in \(\mathsf{ZF}\)).

  To see that \(\widecheck{\aleph_1} \subseteq \aleph_1^{\mathbb{B}}\), let \(x\) be an arbitrary element of \(\widecheck{\aleph_1}\).
  By definition \(x\) is equal to \(\widecheck{\eta}\) for some \(\eta < \aleph_1\) in \lil{pSet}.
  Since the ordinals and cardinals of \lil{pSet} are isomorphic to Lean's ordinals and cardinals for \lil{Type u}, \(\eta\) injects into \(\omega\) (in \lil{pSet}, and also at the level of indexing types).
  Since being an injective function is \(\Delta_0\), it is absolute for \lil{check}, so \(x = \widecheck{\eta}\) injects into \(\omega\).
  Then, by definition of \(\aleph_1^{\mathbb{B}}\), \(x \in \aleph_1^{\mathbb{B}}\).\footnote{Note that this did not use our assumption, and holds for general \(\mathbb{B}\).
  For a conventional proof in a set-theoretic metatheory, see e.g. \cite{bell2011set}}

  To see that \(\aleph_1^{\mathbb{B}} \subseteq \widecheck{\aleph_1}\), suppose towards a contradiction that this is not true; since the ordinals are well-ordered,
  this means that \(\widecheck{\aleph_1} < \aleph_1^{\mathbb{B}}\), so by definition of \(\aleph_1^{\mathbb{B}}\), there is a surjection \(f : \omega \to \widecheck{\aleph_1}\).
  By assumption, this surjection can be lifted to a function \(g : \omega \to \aleph_1\) in \lil{pSet}, which can again be checked to be surjective, a contradiction.

  Similarly, it is true for general \(\mathbb{B}\) that for any \lil{x : pSet}, \(\widecheck{\mathcal{P}(x)} \subseteq \mathcal{P}(\widecheck{x})\),
  because indicator functions into \lil{bool} naturally induce indicator functions to \(\mathbb{B}\) (by composing with the canonical inclusion \lil{bool ‚Üí ùîπ}).
  Conversely, to show that \(\mathcal{P}(\omega) \subseteq \widecheck{\mathcal{P}(\omega)}\), use the isomorphism \(\mathcal{P}(\omega) \simeq \widecheck{2}^{\widecheck{\omega}}\) to reduce this to showing that \(\widecheck{2}^{\widecheck{\omega}} \subseteq \widecheck{2^{\omega}}\),
  and then apply the assumption to an arbitrary element of \(\widecheck{2}^{\widecheck{\omega}}\).
\end{proof}

It remains to show that \lil{ùîπ_collapse} fulfills the assumptions of \Cref{lemma-function-reflect-suffices}.

\begin{lemma}\label{lemma-function-reflect}
  For every \lil{ y : pSet}, and every \lil{f : bSet ùîπ_collapse} such that \lil{bSet ùîπ_collapse} models that \lil{f} is a function from \(\omega\) to \(\widecheck{y}\),
  there exists a \lil{g : pSet} such that \lil{g} is a function from \(\omega\) to \lil{y} in \lil{pSet}, and \lil{bSet ùîπ_collapse} models that \(\widecheck{g} = f\).
\end{lemma}

% \subsection{Reflecting Boolean-valued \(\forall\)-\(\exists\) statements into the metatheory} \label{subsect:reflect}

\begin{proof}
  Fix \(y\) and \(f\). It suffices to show that
\begin{lstlisting}
f ‚àà·¥Æ functions œâ yÃå
  ‚â§ ‚®Ü (g : bSet ùîπ),
      g ‚àà·¥Æ (functions omega y)Ãå  ‚äì g =·¥Æ f
\end{lstlisting}
  and by a density argument, it suffices to show that for every principal open \(D_p\),
\begin{lstlisting}
‚ä• < (‚ãÉ g, D_p ‚äì g ‚àà·¥Æ (functions omega y)Ãå  ‚äì g =·¥Æ f)
\end{lstlisting}
  It suffices to construct a single function \(g : \omega \to y\) such that \(\bot < D_p \sqcap \widecheck{g} = f\).
  As with Cohen forcing, we will reflect a Boolean-valued \(\forall\)-\(\exists\) statement into the metatheory, and then use a combinatorial property of \lil{ùîπ_collapse} to strengthen it.
  The following lemma is true for general \(\mathbb{B}\):
\begin{lstlisting}
lemma AE_of_check_func_check (x y : pSet.{u}) {f : bSet ùîπ} {Œì : ùîπ}
  (H : Œì ‚â§ is_func' xÃå yÃå f) (H_nonzero : ‚ä• < Œì) :
  Œ† (i : x.type),
    ‚àÉ (j : y.type ) (Œì' : ùîπ) (H_nonzero' : ‚ä• < Œì') (H_le : Œì' ‚â§ Œì),
      Œì' ‚â§ (is_func' xÃå yÃå f) ‚àß Œì' ‚â§ (pair (x.func i)Ãå  (y.func j)Ãå ) ‚àà·¥Æ f :=
\end{lstlisting}
Recursively applying this lemma, obtain values \(g_0, \dots, g_n, \dots\) such that

\[\bot < \dots < D_p \sqcap \left(\bigsqcap_{k \leq n} ((k, g_k) \in^{\mathbb{B}} f)\right) < \cdots < D_p \sqcap (0 , g_0) \in^{\mathbb{B}} f\]

The intersection of this chain implies that \(g := \{(k, g_k)\}_{k \in \omega}\) is the required lift of \(f\). For general \(\mathbb{B}\), this intersection might be \(\bot\), but because \lil{ùîπ_collapse} is \(\sigma\)-closed, we can shrink each term of the above chain into a dense suborder \(\mathcal{D}\) such that all downward \(\omega\)-indexed chains in \(\mathcal{D}\) have nonzero intersection, so the intersection of the chain is indeed nonzero.
\end{proof}

\paragraph{Concluding remarks}
 - In Cohen forcing, unlike collapse forcing, constructing the new function required no denseness arguments at all. However, proving the required combinatorial property on \(\mathbb{B}\) was more delicate than just observing that a union of countable partial functions is again countable.

% TODO(jesse): reorganize and put into other sections
% To prove that the regular open algebra RO (2^(aleph_2 x omega)) for Cohen forcing has the CCC, a much more direct argument suffices. Given an antichain of regular opens, shrink them to basic clopens, which can then be identified with finite partial functions (p_i : aleph_2 x omega -> 2). Disjointness is equivalent to the finite partial functions all disagreeing with each other at some point. It suffices to show that for every n : N that there are only finitely many p_i of cardinality n. It's easy to see this for n = 1, and at the induction step, fix some p* and towards a contradiction if there are infinitely many, then we can use the pigeonhole principle to get an infinite subfamily (q_i) which disagree with p* at the same point. Then the (q_i) agree at that point, so that point can be removed, contradicting the induction hypothesis.

% This is indeed more delicate than proving the corresponding combinatorial property on the forcing CH side, where we just observe that a countable union of countable partial functions is again a countable partial function, but after this point the rest of the Cohen forcing argument is very easy (I just checked and we actually don't use a denseness argument at all), while collapse forcing uses denseness in an essential way in multiple places.



% partial functions in Lean, introduce the collapsing boolean algebra, show omega-closedness.

% Construction of $\aleph_1$.

\subsection{The independence of CH} \label{subsection:forcing:independence}
\begin{lstlisting}
theorem CH_unprovable_from_ZFC : ¬¨ (ZFC' ‚ä¢' CH_sentence) :=
unprovable_of_model_neg (V ùîπ_cohen) fundamental_theorem_of_forcing
  (nontrivial.bot_lt_top) V_ùîπ_cohen_models_neg_CH

theorem neg_CH_unprovable_from_ZFC : ¬¨ (ZFC' ‚ä¢' ‚àºCH_sentence) :=
unprovable_of_model_neg (V ùîπ_collapse) fundamental_theorem_of_forcing
  (nontrivial.bot_lt_top) (by {rw forced_in_not, from V_ùîπ_collapse_models_CH})

def independent {L : Language} (T : Theory L) (f : sentence L) : Prop :=
¬¨ (T ‚ä¢' f ‚à® T ‚ä¢' ‚àºf)

theorem independence_of_CH : independent ZFC' CH_sentence :=
by finish[independent, CH_unprovable_from_ZFC, neg_CH_unprovable_from_ZFC]
\end{lstlisting}
\section{Automation and metaprogramming}
\label{section:metaprogramming}

A key feature of Lean is that it is its own metalanguage \cite{Ebner:2017:MFF:3136534.3110278}, allowing for seamless in-line definitions of custom tactics (and modifications of existing ones).
This feature was an invaluable asset, as it allowed the rapid development of a custom tactic library for simulating natural-deduction style proofs in complete Boolean algebras (\Cref{subsect:natded}) and automating equality reasoning in those proofs (\Cref{subsect:bv-cc}).

\subsection{Simulating natural deduction proofs in \(\mathbb{B}\)} \label{subsect:natded}
As stressed by Scott \cite{scott2008algebraic}, ``A main point ... is that the well-known algebraic characterizations of [complete Heyting algebras] and [complete Boolean algebras] exactly mimic the rules of deduction in the respective logics.''
Indeed, that is really why the Boolean-valued soundness theorem (see \Cref{boolean-soundness}) is true. One thinks of the \lil{‚â§} symbol in an inequality of Boolean truth-values as a turnstile in a proof state:
the conjuncts on the left as a list of assumptions in context, and the quantity on the right as the goal.
For example, given \lil{a b : ùîπ}, the identity $(a \Rightarrow b) \sqcap a \leq b$ could be proven by unfolding the definition of material implication, but it is really just modus ponens;
similarly, given an indexed family \lil{a : I ‚Üí ùîπ}, the equivalence \lstinline{(‚®Üi, a i ‚â§ b) ‚Üî ‚àÄ i, a i ‚â§ b} is just $\exists$-elimination.

Difficulties arise when the statements to be proved become only slightly more complicated. Consider the following example, which should be  ``\lil{by assumption}'':
\begin{lstlisting}
  ‚àÄ a b c d e f g: ùîπ, (d ‚äì e) ‚äì (f ‚äì g ‚äì ((b ‚äì a) ‚äì c)) ‚â§ a
\end{lstlisting}
or slightly less trivially, the following example where the goal is attainable by ``implication introduction and \emph{modus ponens}''
\begin{lstlisting}
(a ‚üπ b) ‚äì (b ‚üπ c) ‚â§ a ‚üπ c
\end{lstlisting}
In this last example, even if one has a lemma which concludes \lil{a ‚üπ b ‚äì a ‚â§ b}, one must perform tedious reasoning modulo the associativity and commutativity of \(\sqcap\) to apply it.
Our solution is to piggyback on top of the tactic monad's AC-invariant handling of hypotheses in the tactic state, by applying the \textbf{Yoneda lemma} for posets, which we formulate as
\label{poset-yoneda}
\begin{lstlisting}
lemma poset_yoneda {Œ≤} [partial_order Œ≤] {a b : Œ≤}
(H : ‚àÄ Œì : Œ≤, Œì ‚â§ a ‚Üí Œì ‚â§ b) : a ‚â§ b
\end{lstlisting}
With a little custom automation, our first example nearly becomes ``\lil{by assumption}''
\begin{lstlisting}
example {a b c d e f g : ùîπ} : (d ‚äì e) ‚äì (f ‚äì g ‚äì((b ‚äì a)‚äì c)) ‚â§ a :=
by {tidy_context, assumption}
/-  Goal state before `assumption`:
  [...]
  H_right_right_left_left : Œì ‚â§ b,
  H_right_right_left_right : Œì ‚â§ a
  ‚ä¢ Œì ‚â§ a  -/
\end{lstlisting}
Above, \lil{tidy_context} combines an application of this lemma with a call to the simplifier to split hypotheses of the form \lstinline{Œì ‚â§ a‚ÇÅ ‚äì a‚ÇÇ ‚äì ... a‚Çô} into \lstinline{Œì ‚â§ a‚ÇÅ, Œì ‚â§ a‚ÇÇ, ..., Œì ‚â§ a‚Çô}.
With more custom tactics and coercions to simulate natural deduction proof steps in \(\mathbb{B}\), our second example is handled just as easily:
\begin{lstlisting}
example {ùîπ} [complete_boolean_algebra ùîπ]
 {a b c : ùîπ} :
 ( a ‚üπ b ) ‚äì ( b ‚üπ c ) ‚â§ a ‚üπ c :=
  by {tidy_context, bv_imp_intro Ha,
      exact a_1_right (a_1_left Ha)}
\end{lstlisting}
Compare this with a more conventional proof, where we have the deduction theorem and modus ponens available as lemmas:
\begin{lstlisting}
example {Œ≤ : Type*} [complete_boolean_algebra Œ≤] {a b c : Œ≤} :
 ( a ‚üπ b ) ‚äì ( b ‚üπ c ) ‚â§ a ‚üπ c :=
begin
  rw [‚Üêdeduction, inf_comm, ‚Üêinf_assoc],
  transitivity b ‚äì b ‚üπ c,
    { refine le_inf _ _,
      { apply inf_le_left_of_le, rw inf_comm, apply mp },
      { apply inf_le_right_of_le, refl }},
    { rw inf_comm, apply mp }
end
\end{lstlisting}
One use-case where automation is crucial is context specialization.
For example, suppose that after preprocessing with \lstinline{poset_yoneda}, the goal is \lstinline{Œì ‚â§ (a ‚üπ b)}, and one would like to apply implication introduction,
adding \lstinline{Œì ‚â§ a} to the context and reducing the goal to \lstinline{Œì ‚â§ b}.
This is impossible as stated. Rather, the deduction theorem lets us rewrite the goal to \lstinline{Œì ‚äì a ‚â§ b}, and now we may add \lstinline{Œì ‚äì a ‚â§ a} to the context.
So we may introduce the implication after all, but at the cost of specializing the context \lstinline{Œì} to the smaller context \lstinline{Œì' := Œì ‚äì a}.
But now, in order for the user to continue the pretense that they are merely doing first-order logic, this change of variables must be propagated to the rest of the assumptions which may still be of the form \lstinline{Œì ‚â§ _}---which is extremely tedious to do by hand, but easy to automate.

It would have been possible to go further and even write a custom tactic state,
as was done for temporal logic in Unit-B \cite{Hudon2015TheUM} or for Lean's SMT-mode framework,
such that the machinery for handling the ambient context \(\Gamma\) is completely hidden and the Boolean-valued tactics receive their own namespace.
However, we felt the benefits of doing so in our formalization would have been mostly cosmetic, and we leave more sophisticated implementations for future work.

\subsection{Boolean-valued equality reasoning}

\paragraph{Congruence closure on quotient types} \label{subsect:bv-cc}
Another benefit of applying \hyperref[poset-yoneda]{\lstinline{poset_yoneda}} and using context variables \(\Gamma\) throughout the formalization is that this approach exposes a canonical family of setoids on \lil{bSet ùîπ} induced by \lil{ùîπ}-valued equality:
for every \(\Gamma : \mathbb{B}\), \(\lambda\; x \; y, \Gamma \leq x =^{\mathbb{B}} y\) is an equivalence relation on \lil{bSet ùîπ} (the larger \(\Gamma\) is, the finer the equivalence relation).

Since Lean natively supports quotient types, then as soon as e.g. all (Boolean-valued) existentials have been split and the only task remaining is to perform equality reasoning,
we can quotient by the appropriate setoid and simply call \lil{cc};
this is easy to automate with a custom tactic \lil{bv_cc}:
\begin{lstlisting}
example {x y z x‚ÇÅ y‚ÇÅ z‚ÇÅ: bSet ùîπ} {Œì : ùîπ}
  (H1 : Œì ‚â§ x =·¥Æ y) (H2 : Œì ‚â§ y =·¥Æ z)
  (H3 : Œì ‚â§ z =·¥Æ z‚ÇÅ) (H4 : Œì ‚â§ z‚ÇÅ =·¥Æ y‚ÇÅ)
  (H5 : Œì ‚â§ y‚ÇÅ =·¥Æ x‚ÇÅ) : Œì ‚â§ x =·¥Æ x‚ÇÅ := by bv_cc
\end{lstlisting}
We can add support for any predicate satisfying an appropriate \(\mathbb{B}\)-valued congruence lemma,
although we do not have a way of handling such extensions uniformly and currently add support for individual predicates by hand:
\begin{lstlisting}
example {x‚ÇÅ y‚ÇÅ x‚ÇÇ y‚ÇÇ : bSet ùîπ} {Œì}
  (H‚ÇÅ : Œì ‚â§ x‚ÇÅ ‚àà·¥Æ y‚ÇÅ) (H‚ÇÇ : Œì ‚â§ x‚ÇÅ =·¥Æ x‚ÇÇ)
  (H‚ÇÇ : Œì ‚â§ y‚ÇÅ =·¥Æ y‚ÇÇ) : Œì ‚â§ x‚ÇÇ ‚àà·¥Æ y‚ÇÇ := by bv_cc
\end{lstlisting}
\paragraph{Discharging congruence lemmas via \texttt{simp}} Rewriting along \(\mathbb{B}\)-valued equality is the same as rewriting in the appropriate setoid parametrized by the current context \(\Gamma\),
so that the motive must satisfy an appropriate \emph{congruence lemma} \lil{h_congr} with respect to the equivalence relation:
\begin{lstlisting}
lemma bv_rw {x y : bSet ùîπ} {Œì : ùîπ}
  (H : Œì ‚â§ x =·¥Æ y) {œï : bSet ùîπ ‚Üí ùîπ}
  {h_congr : ‚àÄ x y, x =·¥Æ y ‚äì œï x ‚â§ œï y}
  {H_new : Œì ‚â§ œï y} : Œì ‚â§ œï x
\end{lstlisting}
We alias the type of \lil{h_congr}, and add a database of \lil{@[simp]} lemmas expressing that congruence lemmas are preserved by first-order logical operations:
\begin{lstlisting}
def B_ext (œï : bSet ùîπ ‚Üí ùîπ) : Prop := ‚àÄ x y, x =·¥Æ y ‚äì œï x ‚â§ œï y
@[simp]lemma B_ext_infi {Œπ} {œï : Œπ ‚Üí (bSet ùîπ ‚Üí ùîπ)} {h : ‚àÄ i, B_ext (œï i)} : B_ext (Œª x, ‚®Öi, œï i x)
\end{lstlisting}
Surprisingly, \lil{simp} is able to handle recursive applications of these lemmas on its own, allowing most congruence lemma proof obligations to be automatically discharged:
\begin{lstlisting}
example {w : bSet ùîπ} : (let œï :=
  Œª x, ‚®Ö z, z ‚àà·¥Æ w ‚äì z ‚äÜ·¥Æ x ‚äì x ‚äÜ·¥Æ z
  in B_ext œï) := by simp
\end{lstlisting}
\section{Related Work}
\label{section:related-work}
Compare with other formalization on the consistency of CH.

\section{Conclusions}
\label{section:conclusions}

% TODO(jesse): polish, and maybe move to a footnote in the introduction?
This paper describes a successful completion of the Flypitch project, giving the first formalization of the independence of the continuum hypothesis.
This problem is problem 24 on Wiedijk's list ``Formalizing 100 theorem''~\cite{wiedijk100theorems},
and this is the 95-th formalized result of that list.

\subsection{Future Work}

%TODO(jesse): polish
This formalization consists of a reusable library which can be used for future formalizations in first-order logic, model theory and set theory.
We have just scratched the surface of modern set theory with this formalization, and it would be interesting to formalize some more modern results.
In this section we will focus only on results directly related to the results in our paper.

In this paper we used \(\sigma\)-closed forcing to show the consistency of $\CH$.
It would be interesting to formalize the construction of $L$, the constructible hierarchy.
In $L$ the generalized continuum hypothesis $\mathsf{GCH}$ also holds, which states that $2^{\aleph_\alpha}=\aleph_{\alpha+1}$ for all ordinals $\alpha$.
The consistency of $\mathsf{GCH}$ can also be shown by an iterated forcing argument, but this proof is significantly more involved than the proof in this paper.

There are also many generalizations of the consistency of $\neg \mathsf{CH}$.
We could generalize it to the consistency of $\mathfrak{c}=\aleph_\alpha$, for any cardinal $\aleph_\alpha$ with uncountable cofinality.
Or more generally, we could formalize Easton's theorem, which states that on regular cardinals the function $\kappa\mapsto 2^\kappa$ can be any monotone function that doesn't contradicts K\"onig's Theorem ($\kappa<\cf(2^\kappa)$)~\cite{easton1970powers}.

We want to formalize that extending a language by definable constant and function symbols is conservative.
This would show that $\CH$ is independent of the usual presentation of $\ZFC$, in the language with only one relation symbol.
Furthermore, it would be nice to have a better parser and printer for sentences in first-order logic, since writing them by hand is pretty painful with de Bruijn variables.

%% Acknowledgments
\begin{acks}                            %% acks environment is optional
                                        %% contents suppressed with 'anonymous'
  %% Commands \grantsponsor{<sponsorID>}{<name>}{<url>} and
  %% \grantnum[<url>]{<sponsorID>}{<number>} should be used to
  %% acknowledge financial support and will be used by metadata
  %% extraction tools.
  The authors gratefully acknowlege the support by the
  \grantsponsor{GS100000001}{Alfred P. Sloan Foundation}{https://doi.org/10.1038/201765d0}, Grant
  No.~\grantnum{GS100000001}{G-2018-10067}.
\end{acks}

%% Bibliography
\bibliography{flypitch-cpp}

%% Appendix
% \appendix
% \section{Appendix}

% Text of appendix \ldots

\end{document}
