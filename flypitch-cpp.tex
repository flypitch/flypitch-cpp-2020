%% For double-blind review submission, w/o CCS and ACM Reference (max submission space)
\documentclass[sigplan,10pt,review, anonymous]{acmart}

% note(jesse, October 01 2019, 04:00 PM): I'm getting weird typesetting authors when the `anonymous' option is removed

% add: anonymous
\settopmatter{printfolios=true,printccs=false,printacmref=false}
%% For double-blind review submission, w/ CCS and ACM Reference
%\documentclass[sigplan,review,anonymous]{acmart}\settopmatter{printfolios=true}
%% For single-blind review submission, w/o CCS and ACM Reference (max submission space)
%\documentclass[sigplan,review]{acmart}\settopmatter{printfolios=true,printccs=false,printacmref=false}
%% For single-blind review submission, w/ CCS and ACM Reference
%\documentclass[sigplan,review]{acmart}\settopmatter{printfolios=true}
%% For final camera-ready submission, w/ required CCS and ACM Reference
%\documentclass[sigplan]{acmart}\settopmatter{}


%% Conference information
%% Supplied to authors by publisher for camera-ready submission;
%% use defaults for review submission.
\acmConference[CPP'20]{The 9th ACM SIGPLAN International Conference on Certified Programs and Proofs}{January 20--21, 2020}{New Orleans, LA, USA}
\acmYear{2020}
\acmISBN{} % \acmISBN{978-x-xxxx-xxxx-x/YY/MM}
\acmDOI{} % \acmDOI{10.1145/nnnnnnn.nnnnnnn}
\startPage{1}

%% Copyright information
%% Supplied to authors (based on authors' rights management selection;
%% see authors.acm.org) by publisher for camera-ready submission;
%% use 'none' for review submission.
\setcopyright{none}
%\setcopyright{acmcopyright}
%\setcopyright{acmlicensed}
%\setcopyright{rightsretained}
%\copyrightyear{2018}           %% If different from \acmYear

%% Bibliography style
\bibliographystyle{ACM-Reference-Format}
%% Citation style
%\citestyle{acmauthoryear}  %% For author/year citations
%\citestyle{acmnumeric}     %% For numeric citations
%\setcitestyle{nosort}      %% With 'acmnumeric', to disable automatic
                            %% sorting of references within a single citation;
                            %% e.g., \cite{Smith99,Carpenter05,Baker12}
                            %% rendered as [14,5,2] rather than [2,5,14].
%\setcitesyle{nocompress}   %% With 'acmnumeric', to disable automatic
                            %% compression of sequential references within a
                            %% single citation;
                            %% e.g., \cite{Baker12,Baker14,Baker16}
                            %% rendered as [2,3,4] rather than [2-4].


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Note: Authors migrating a paper from traditional SIGPLAN
%% proceedings format to PACMPL format must update the
%% '\documentclass' and topmatter commands above; see
%% 'acmart-pacmpl-template.tex'.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%% Some recommended packages.
\usepackage{booktabs}   %% For formal tables:
                        %% http://ctan.org/pkg/booktabs
\usepackage{subcaption} %% For complex figures with subfigures/subcaptions
%% http://ctan.org/pkg/subcaption

\usepackage{color}
\definecolor{keywordcolor}{rgb}{0.7, 0.1, 0.1}   % red
\definecolor{tacticcolor}{rgb}{0.1, 0.2, 0.6}    % blue
\definecolor{commentcolor}{rgb}{0.4, 0.4, 0.4}   % grey
\definecolor{symbolcolor}{rgb}{0.0, 0.1, 0.6}    % blue
\definecolor{sortcolor}{rgb}{0.1, 0.5, 0.1}      % green
\definecolor{attributecolor}{rgb}{0.7, 0.1, 0.1} % red

% TODO: replace \check and ̌  by \widecheck
%% code from mathabx.sty and mathabx.dcl
%% This code is here to define the \widecheck control sequence without importing mathabx
\DeclareFontFamily{U}{mathx}{\hyphenchar\font45}
\DeclareFontShape{U}{mathx}{m}{n}{
      <5> <6> <7> <8> <9> <10>
      <10.95> <12> <14.4> <17.28> <20.74> <24.88>
      mathx10
      }{}
\DeclareSymbolFont{mathx}{U}{mathx}{m}{n}
\DeclareFontSubstitution{U}{mathx}{m}{n}
\DeclareMathAccent{\widecheck}{0}{mathx}{"71}
\DeclareMathAccent{\wideparen}{0}{mathx}{"75}

\usepackage{listings}
\def\lstlanguagefiles{lstlean.tex}
\lstset{language=lean,breakatwhitespace,xleftmargin=0pt, basicstyle=\ttfamily\small}
\usepackage{stmaryrd}
\newcommand{\B}{\mathbb{B}}
\newcommand{\lil}{\lstinline}
\newcommand{\N}{\mathbb{N}}
\newcommand{\ZFC}{\mathsf{ZFC}}
\newcommand{\CH}{\mathsf{CH}}

\usepackage{amsthm}
% \theoremstyle{theorem}
\newtheorem{thm}{Theorem}[section]
\theoremstyle{definition}
\newtheorem{defn}{Definition}[section]
\newtheorem{remark}{Remark}[section]
\DeclareMathOperator{\cf}{cf}
\DeclareMathOperator{\Ord}{Ord}

\usepackage{tikz-cd}

\begin{document}

%% Title information
\title{A Formal Proof of the Independence of the Continuum Hypothesis}
                                        %% [Short Title] is optional;
                                        %% when present, will be used in
                                        %% header instead of Full Title.
% \titlenote{with title note}             %% \titlenote is optional;
                                        %% can be repeated if necessary;
                                        %% contents suppressed with 'anonymous'
% \subtitle{Subtitle}                     %% \subtitle is optional
% \subtitlenote{with subtitle note}       %% \subtitlenote is optional;
                                        %% can be repeated if necessary;
                                        %% contents suppressed with 'anonymous'


%% Author information
%% Contents and number of authors suppressed with 'anonymous'.
%% Each author should be introduced by \author, followed by
%% \authornote (optional), \orcid (optional), \affiliation, and
%% \email.
%% An author may have multiple affiliations and/or emails; repeat the
%% appropriate command.
%% Many elements are not rendered, but should be provided for metadata
%% extraction tools.

%% Author with single affiliation.
\author{Jesse Michael Han}
% \authornote{with author1 note}          %% \authornote is optional;
                                        %% can be repeated if necessary
% \orcid{nnnn-nnnn-nnnn-nnnn}             %% \orcid is optional
\affiliation{
  % \position{Position1}
  \department{Department of Mathematics}              %% \department is recommended
  \institution{University of Pittsburgh}            %% \institution is required
  \streetaddress{4200 Fifth Ave}
  \city{Pittsburgh}
  \state{PA}
  \postcode{15260}
  \country{USA}                    %% \country is recommended
}
\email{jessemichaelhan@gmail.com}          %% \email is recommended

%% Author with two affiliations and emails.
\author{Floris van Doorn}
% \authornote{with author2 note}          %% \authornote is optional;
                                        %% can be repeated if necessary
\orcid{0000-0003-2899-8565}             %% \orcid is optional
\affiliation{
  % \position{Position2a}
  \department{Department of Mathematics}              %% \department is recommended
  \institution{University of Pittsburgh}            %% \institution is required
  \streetaddress{4200 Fifth Ave}
  \city{Pittsburgh}
  \state{PA}
  \postcode{15260}
  \country{USA}                    %% \country is recommended
}
\email{fpvdoorn@gmail.com}         %% \email is recommended

%% Abstract
%% Note: \begin{abstract}...\end{abstract} environment must come
%% before \maketitle command
\begin{abstract}
  We describe a formal proof of the independence of the continuum hypothesis (\(\mathsf{CH}\)) in the Lean theorem prover. We use Boolean-valued models to give forcing arguments for both directions, using Cohen forcing for the consistency of \(\neg \mathsf{CH}\) and a \(\sigma\)-closed forcing for the consistency of \(\mathsf{CH}\).

  % reasons for changes:

  % `Cohen forcing' means a very particular type of forcing which has a unique implementation on either the ctm or bvm side, but 'sigma-closed' is merely a combinatorial condition on a forcing poset/boolean algebra the same way that 'kappa-cc' is

  % avoid double negation e.g. 'not disprovable' by formulating in terms of consistency instead
  % i doubt anyone will be confused by this and we'll have to explain somewhere why the soundness theorem lets us use consistency results to prove unprovability results anyways

% We use Boolean-valued models and forcing to give a formal proof of the independence of the continuum hypothesis ($\mathsf{CH}$) in the Lean theorem prover. We use a forcing argument for both directions, using Cohen forcing to show that $\mathsf{CH}$ is unprovable and using $\sigma$-closed forcing to show that $\mathsf{CH}$ is not disprovable.
\end{abstract}


%TODO
%% 2012 ACM Computing Classification System (CSS) concepts
%% Generate at 'http://dl.acm.org/ccs/ccs.cfm'.
% \begin{CCSXML}
% <ccs2012>
% <concept>
% <concept_id>10011007.10011006.10011008</concept_id>
% <concept_desc>Software and its engineering~General programming languages</concept_desc>
% <concept_significance>500</concept_significance>
% </concept>
% <concept>
% <concept_id>10003456.10003457.10003521.10003525</concept_id>
% <concept_desc>Social and professional topics~History of programming languages</concept_desc>
% <concept_significance>300</concept_significance>
% </concept>
% </ccs2012>
% \end{CCSXML}

% \ccsdesc[500]{Software and its engineering~General programming languages}
% \ccsdesc[300]{Social and professional topics~History of programming languages}
%% End of generated code


%TODO
%% Keywords
%% comma separated list
\keywords{continuum hypothesis, forcing, Lean, set theory, ZFC} %% \keywords are mandatory in final camera-ready submission


%% \maketitle
%% Note: \maketitle command must come after title commands, author
%% commands, abstract environment, Computing Classification System
%% environment and commands, and keywords command.
\maketitle


\section{Introduction}
\label{section:intro}
The continuum hypothesis ($\mathsf{CH}$) states that there is no cardinality between $\omega$, the smallest infinite cardinal and $\mathfrak{c}$, the cardinality of the continuum.
It was introduced by Cantor \cite{cantor1878beitrag} in 1878 and was the very first problem on Hilbert's list of twenty-three outstanding problems in mathematics.
G\"odel \cite{godel1938consistency} proved in 1938 that $\mathsf{CH}$ was consistent with $\mathsf{ZFC}$, and later conjectured that $\mathsf{CH}$ is independent of $\mathsf{ZFC}$, i.e. neither provable nor disprovable from the $\mathsf{ZFC}$ axioms.
In 1963, Paul Cohen developed \emph{forcing} \cite{cohen-the-independence-of-the-continuum-hypothesis-1,cohen1964independence2}, which allowed him to prove the consistency of $\neg \mathsf{CH}$, and therefore complete the independence proof.
For this work, which marked the beginning of modern set theory, he was awarded a Fields medal---the only one to ever be awarded for a work in mathematical logic.

In this paper we describe the successful completion of the Flypitch project\footnote{\url{https://flypitch.github.io}} (\textbf{F}ormal\textbf{ly} \textbf{p}roving the \textbf{i}ndependence of \textbf{t}he \textbf{c}ontinuum \textbf{h}ypothesis).
For both parts of the independence of the continuum hypothesis, we use forcing to construct a Boolean-valued model of $\mathsf{ZFC}$.
To show that $\mathsf{CH}$ is consistent, we use $\sigma$-closed forcing, to collapse the cardinality of the continuum to $\aleph_1$.
To show that $\neg \mathsf{CH}$ is consistent, we use Cohen forcing, to add $\aleph_2$ many new real numbers, giving an injection from $\aleph_2$ into the continuum.
The consistency of $\neg \mathsf{CH}$ already appeared in \cite{DBLP:conf/itp/HanD19}, and we will summarize this proof briefly.
This forcing argument to show that $\mathsf{CH}$ is consistent is not the proof that G\"odel gave in 1938, who instead used the constructible universe $L$, where $\mathsf{CH}$ holds. We decided to formalize this proof so that we used an forcing argument for both parts of the independence.

The method of forcing with Boolean-valued models was developed by Solovay and Scott in '65-'66 \cite{scott1967proof,scott-solovay} as a simplification of Cohen's method.
Some of these simplifications were incorporated by Shoenfield \cite{shoenfield1971unramified} into a general theory of forcing using partial orders, and it is in this form that forcing is usually practiced.
While both approaches have essentially the same mathematical content (see e.g.\ \cite{kunen2014set, jech2013set, moore2019method}), there are several reasons why we chose Boolean-valued models for our formalization.
The main reason is the directness of forcing with boolean-valued models.
Our formalization doesn't require us to prove the L\"owenheim-Skolem theorems, Mostowski collapse, countable transitive models, or genericity considerations for filters.
Instead, we had to set up a library for Boolean-valued models, including a soundness theorem for Boolean-valued models, but this was similar to the library for ordinary two-valued models.

We have set up our library in a modular fashion, which allowed us to formalize different components in parallel. Some of the components are
\begin{itemize}
  \item A general theory of Boolean-valued semantics for first-order logic;
  \item A library for calculations inside complete Boolean algebras;
  \item The construction of Boolean-valued models of set theory;
  \item The construction of the appropriate Boolean algebras;
  \item The theory of \(\mathsf{ZFC}\) set theory.
\end{itemize}
These components could then be combined to perfom the specific forcing arguments.
We made sure that the individual components of this formalization are reusable for other projects, e.g.\ to formalize the Boolean-valued semantics of stochastic $\lambda$-calculus~\cite{scott2014stochastic, bacci2018boolean}.

%TODO: maybe this is better in the main text. We can mention in briefly here.
% \textbf{Amenability to structural induction.}
% As with Coq, Lean is able to encode extremely complex objects and reason about their specifications using inductive types.
% However, the user must be careful to choose the encoding so that properties they wish to reason about are accessible by structural induction, which is the most natural mode of reasoning in the proof assistant.
% After observing (1) that the Aczel-Werner encoding of $\mathsf{ZFC}$ as an inductive type is essentially a special case of the recursive \emph{name} construction from forcing (c.f. Section \ref{section:boolean-semantics}),
% and (2) that the automatically-generated induction principle for that inductive type \emph{is} $\in$-induction,
% it is easy to see that this encoding can be modified to produce a Boolean-valued model of set theory where, again, $\in$-induction comes for free.

Our formalization\footnote{\url{https://github.com/flypitch/flypitch}} is written in the Lean 3 theorem prover, building on top of \textsf{mathlib}~\cite{mathlib}.
Lean is an interactive proof assistant under active development at Microsoft Research~\cite{de2015lean, ullrich2019counting}.
It implements the Calculus of Inductive Constructions and has a similar metatheory to Coq, adding definitional proof irrelevance, quotient types, and a noncomputable choice principle.
Our formalization makes as much use of the expressiveness of Lean's dependent type theory as possible, using constructions which are impossible or unwieldy to encode in HOL, much less ZF.
We crucially use the types of cardinals and ordinals defined in \textsf{mathlib}, which are defined as equivalence classes of types and well-ordered types, respectively. Ordinals and cardinals live one universe level higher than the types used to construct them.
Moreover, the models of set theory \lstinline{pSet} and \lstinline{bSet} we use, require as input an entire universe of types.
Finally, our encoding of first-order logic uses parameterized inductive types which ensures that type-correctness implies well-formedness. This eliminates the need for separate well-formedness proofs.

%TODO: maybe rephrase or move into future work
The results in this paper are not the most general possible results.
Instead of showing the consistency of $\mathsf{CH}$ we could have shown the consistency of the generalized continuum hypothesis $\mathsf{GCH}$, which states that $2^{\aleph_\alpha}=\aleph_{\alpha+1}$ for all ordinals $\alpha$.
The generalized continuum hypothesis is true in the constructible universe $L$, and its consistency can be shown by a forcing argument, but this forcing argument is significantly more involved than the forcing argument for $\mathsf{CH}$.
We could generalize the consistency of $\neg \mathsf{CH}$ to the consistency of $\mathfrak{c}=\aleph_\alpha$, for any cardinal $\aleph_\alpha$ with uncountable cofinality.
Or more generally, that on regular cardinals the function $\kappa\mapsto 2^\kappa$ can be any monotone function not contradicting K\"onig's Theorem ($\cf(2^\kappa)>\kappa$)~\cite{easton1970powers}.

\subsection{Proof Outline}
\label{subsection:intro:outline}
$\ZFC$ is a collection of first-order sentences in the language of set theory. For convenience, we extend set theory to have five definable function symbols in addition to the membership relation (see Section~\ref{subsection:fol:zfc}).
In this language we can easily formulate $\CH$.
The goal of our formalization is to show that we cannot construct proofs of either $\CH$ or $\neg\CH$ from $\ZFC$.
By proof we mean a natural deduction tree (see Section~\ref{subsection:fol:terms}).

The usual method to show that there is no proof of a certain statement is to construct a model where the statement is false, and apply the soundness theorem.
Our method is similar, except that we use Boolean-valued models (see Section~\ref{section:boolean-semantics}).
The difference between Boolean-valued models and ordinary models is that the truth values in a Boolean-valued model \lil{M} live in a specified complete Boolean algebra \lil{𝔹}.
This means that, e.g.\ equality is interpreted as a function \lil{eq : M → M → 𝔹} and transitivity is formulated as \lil{eq(x, y) ⊓ eq(y, z) ≤ eq(x, z)} for all \lil{x, y, z}.
Here \lil{⊓} and \lil{≤} are the meet and order in \lil{𝔹}.
For equality, we also have to specify that it is reflexive, symmetric, and respects all the interpretations of function symbols and relation symbols in \lil{M}.
Our task is now to construct two Boolean-valued models of $\ZFC$, one where $\CH$ holds, and one where $\CH$ fails.
We then apply the soundness theorem for Boolean-valued models to show that $\CH$ is independent from $\ZFC$.

For any complete Boolean algebra $\mathbb{B}$ we can construct the type of $\mathbb{B}$-valued sets, or \lil{bSet 𝔹} (see Section~\ref{section:bset}).
An element of \lil{x : bSet 𝔹} has three components:
\begin{itemize}
\item An indexing type \lil{α : Type};
\item A function \lil{A : α → bSet 𝔹} pointing to the (possible) elements of \lil{x};
\item A \lil{𝔹}-valued predicate \lil{B : α → 𝔹} which expresses that \lil{A a ∈ x} has truth value (at least) \lil{B a}.
\end{itemize}
Now the fundamental theorem of forcing states that \lil{bSet 𝔹} forms a boolean-valued model of $\ZFC$.
\lil{bSet 𝔹} is a generalization of Aczel encoding of set theory, which is called \lil{pSet} in Lean.
In this encoding, the third component is missing.
We can also interpret \lil{pSet} as \lil{bSet unit}, where \lil{unit} is the trivial Boolean algebra (with $\top=\bot$).

The properties of \lil{bSet 𝔹} vary wildly depending on the choice of the complete Boolean algebra \lil{𝔹}.
There is always a map \lil{check : pSet → bSet 𝔹}, $x \mapsto \check{x}$, although this map need not be injective and $\check{x}$ might have different properties than $x$. However, properties which are definable with only bounded quantification are preserved. In particular, \lil{bSet 𝔹} thinks $\check{\omega}$ is $\omega$.
We now have to choose two appropriate complete Boolean algebras \lil{𝔹} such that in \lil{bSet 𝔹}, the formula $\CH$ is true ($\top$) in one model and $\CH$ is false ($\bot$) in the other.
This is where forcing comes in (see Section~\ref{section:forcing}).

To force the negation of the continuum hypothesis, we define Cantor space $2^{\aleph_2 \times \mathbb{N}}$ with its usual product topology (see Section~TODO).
Then let $\B$ be the regular open algebra of the Cantor space (a set $O$ is a regular open if $O$ is equal to the interior of the closure of $O$).
Now $\B$ is a complete Boolean algebra, so \lil{bSet 𝔹} models $\ZFC$.
Internally to this model we can construct an injection $\widetilde{\chi} : \aleph_2 \to \mathcal{P}(\omega)$, in the following way.
For each $\nu \in \aleph_2$, we associate the $\B$-valued characteristic function $\chi_\nu : \mathbb{N} \to \B$ by $n \mapsto \{f \mid f(\nu, n) = 1\}$.
This induces an subset $\widetilde{\chi_{\nu}} \subseteq \mathbb{N}$ internal to \lil{bSet 𝔹}, which is called a \emph{Cohen real}.
This way we obtain an function \(\widecheck{\aleph_2} \to \mathcal{P}(\mathbb{N})\) internal to \lil{bSet 𝔹}.
We can now show that \lil{bSet 𝔹} thinks this function is injective, and we finish by showing that \lil{bSet 𝔹} thinks that \(\widecheck{\aleph_2}\) is $\aleph_2$ to show that $\neg\CH$ holds in \lil{bSet 𝔹}.
The proof that \lil{bSet 𝔹} preserves cardinal numbers is really the technical heart of the matter, and relies on a combinatorial property of $\B$ called the \emph{countable chain condition} (CCC).
The proof that $\B$ has the CCC requires a detailed combinatorial analysis of the basis of the product topology for $2^{\aleph_2 \times \mathbb{N}}$.
We handle this with a general result in transfinite combinatorics called the \emph{$\Delta$-system lemma}.
% we can omit the last two sentences, if needed

For the other direction, to force the continuum hypothesis, we define the collapse poset to be the poset of countable partial functions
\[(\mathbb{P}_{\text{collapse}} = \aleph_1 \rightharpoonup \mathcal{P}(\omega).\]
%TODO: use \rightharpoonup by default for partial functions
We can now define a topology on $\aleph_1 \to \mathcal{P}(\omega)$ defined by the principal opens
\[D_p := \{g : \aleph_1 \to \mathcal{P}(\omega) \mid g \text{ extends } p\} \]
for $p \in \mathbb{P}_{\text{collapse}}$.
The collapse algebra $\mathbb{B}_{\text{collapse}}$ is now defined to be the regular opens in this topology.
In the resulting model \lil{bSet 𝔹} we can construct a surjection \(F : \aleph_1 \twoheadrightarrow \mathcal{P}(\omega)\). (TODO) (see Section~TODO)
This depends on \(\sigma\)-closedness (TODO).

This argument is wholly set-theoretic, but we proved it with type theory as our meta-theory.
To do this, it was important to separate the mathematical content from the metamathematical content of the argument.
While our objective is only to produce a model of $\mathsf{ZFC}$ satisfying certain properties, traditional presentations of forcing are careful to stay within the foundations of $\mathsf{ZFC}$, emphasizing that all arguments may be performed internal to a model of $\mathsf{ZFC}$, etc.
It is not immediately clear what parts of the argument use that set-theoretic foundation in an essential way and require modification in the passage to type theory.
Our formalization clarifies some of these questions.

In our formalization, we used many instances of domain-specific tactics and automation (see Section~\ref{section:metaprogramming}).
Lean's powerful metaprogramming language is very convenient to define and run automation, which the user can write in Lean without the need to learn a new language.

\subparagraph*{Sources} % TODO: fully incorporate this section into related work(?)
Our strategy for constructing a Boolean-valued model in which $\mathsf{CH}$ fails is a synthesis of the proofs in the textbooks of Bell (\cite{bell2011set}, Chapter 2) and Manin (\cite{manin2009course}, Chapter 8).
For the $\Delta$-system lemma, we follow Kunen (\cite{kunen2014set}, Chapters 1 and 5).
There is no good reference for the Boolean-valued model where $\CH$ holds.
A conventional argument using filters is given in Weaver \cite{weaver2014forcing}, which we adapted to Boolean-valued models.
See also the Related Work (Section~\ref{section:related-work}).

% \subparagraph*{Viewing the formalization}
% The code blocks in this paper were taken directly from our formalization, but for the sake of readability, we sometimes omit or modify universe levels, type ascriptions, and casts. We refer the interested reader to our repository (see Supplemental Material on page 1) which contains a guide on compiling and navigating the source files of the project.

\section{First-order logic}
\label{section:fol}

The starting point for first-order logic is a \emph{language} of relation and function symbols.
We represent a language as a pair of $\N$-indexed families of types, each of which is to be thought of as the collection of relation (resp. function) symbols stratified by arity:
\begin{lstlisting}
structure Language : Type (u+1) :=
(functions : ℕ → Type u)
(relations : ℕ → Type u)
\end{lstlisting}

\subsection{Terms, Formulae and Proofs}
\label{subsection:fol:terms}
The main novelty of our implementation of first-order logic is the use of \emph{partially applied} terms and formulas, encoded in a parameterized inductive type where the $\N$ parameter measures the difference between the arity and the number of applications.
The benefit of this is that it is impossible to produce an ill-formed term or formula, because type-correctness is equivalent to well-formedness.
This eliminates the need for separate well-formedness proofs.

Fix a language $L$. We define the type of \textbf{preterms} as follows:
\begin{lstlisting}
inductive preterm (L : Language.{u}) :
    ℕ → Type u
| var : ℕ → preterm 0 -- notation `&`
| func {l : ℕ} : L.functions l → preterm l
| app {l : ℕ} :
    preterm (l + 1) → preterm 0 → preterm l
\end{lstlisting}
A member of \lil{preterm n} is a partially applied term.
If applied to \lil{n} terms, it becomes a term.
We define the type of well-formed terms \lil{term L} to be \lil{preterm L 0}.

There are other methods to define well-typed terms, for example using a nested inductive type with a constructor (which replaces the second and third constructor in our definition)
\begin{lstlisting}
| app : ∀ {l : ℕ}, L.functions l →
    vector term l → term
\end{lstlisting}
Here \lil{vector term l} is a $l$-tuple of terms.
Lean has limited support for nested inductive types, but defining definitions by recursion on a nested inductive type is inconvenient.

The type of \textbf{preformulas} is defined similarly:
\begin{lstlisting}
inductive preformula (L : Language.{u}) :
    ℕ → Type u
| falsum : preformula 0 -- notation ⊥
| equal : term L → term L → preformula 0
    -- notation ≃
| rel {l : ℕ}, L.relations l → preformula l
| apprel {l : ℕ}, preformula (l + 1) →
    term L → preformula l
| imp : preformula 0 → preformula 0 →
    preformula 0 -- notation ⟹
| all : preformula 0 → preformula 0
    -- notation ∀'
\end{lstlisting}
A member of \lil{preformula n} is a partially applied formula.
If applied to \lil{n} terms, it becomes a formula.
The type of well-formed formulas \lil{formula L} is defined to be \lil{preterm L 0}.
Implication is the only primitive binary connective and universal quantification is the only primitive quantifier. Since we use classical logic, we can define the other connectives and quantifiers from these.
In particular, we define negation \lil{∼ f} to be \lil{f ⟹ ⊥} and existential quantification \lil{∃' f} to be \lil{∼ ∀' ∼ f}.
Note that implication and the universal quantifier cannot be applied to performulas that are not fully applied.

We choose this definition of \lil{preformula} to mimic \lil{preterm}.
Of course, we could define an inductive type where the constructors \lil{rel} and \lil{apprel} were replaced by the single constructor
\begin{lstlisting}
| rel {l : ℕ} : L.relations l →
    vector term l → formula
\end{lstlisting}
This would not even result in a nested inductive type.
However, we found it more convenient to adapt operations and proofs from \lil{preterm} to \lil{preformula} using our definition.
Using vectors results in some extra proof steps for reasoning about vectors.
Our approach also results in some extra proof steps, but they are the same as the steps in the corresponding proofs for preterms.

We use de Bruijn indices to avoid variable shadowing. This means that the variable \lil{&m} under \lil{k} is bound if $m<k$ and otherwise represents the $(m-k)$-th free variable.
We define the usual operations of lifting and substitution for terms and formulas, needed when using de Bruijn variables.
We use the notation \lil{t ↑' n # m} to mean the preterm of preformula \lil{t} where all variables which are at least \lil{m} are increased by \lil{n}.
The lift \lil{t ↑' n # 0} is abbreviated to \lil{t ↑ n}.
The substitution \lil{t[s // n]} is defined to be the term or formula \lil{t} where all variables that represent the \lil{n}-th free variable are replaced by \lil{s}.
More specifically, if an occurrence of a variable \lil{&(n+k)} is under \lil{k} quantifiers, then it is replaced by \lil{s ↑ (n+k)}.
Variables \lil{&m} for $m>n+k$ are replaced by \lil{&(m-1)}.

Our proof system is a natural deduction calculus, and all rules are motivated to work well with backwards-reasoning. The type of proof trees is given by the following inductive family of types:
\begin{lstlisting}
inductive prf :
    set (formula L) → formula L → Type u
| axm Γ A : A ∈ Γ → prf Γ A
| impI Γ A B : prf (insert A Γ) B →
    prf Γ (A ⟹ B)
| impE Γ A B : prf Γ (A ⟹ B) → prf Γ A →
    prf Γ B
| falsumE Γ A : prf (insert ∼A Γ) ⊥ → prf Γ A
| allI Γ A : prf ((λ f, f ↑ 1) '' Γ) A →
    prf Γ (∀' A)
| allE₂ Γ A t : prf Γ (∀' A) →
    prf Γ (A[t // 0])
| ref Γ t : prf Γ (t ≃ t)
| subst₂ Γ s t f : prf Γ (s ≃ t) →
    prf Γ (f[s // 0]) → prf Γ (f[t // 0])
\end{lstlisting}
In \lil{allI} the notation \lil{(λ f, f ↑ 1) '' Γ} means lifting all free variables in \lil{Γ} by one.
A term of type \lil{prf Γ A}, denoted \lil{Γ ⊢ A}, is a proof tree encoding a derivation of $A$ from $\Gamma$.
We also define provability as the proposition stating that a proof tree exists.
\begin{lstlisting}
def provable (Γ : set (formula L)) (f : formula L) :
    Prop :=
nonempty (prf Γ f)
\end{lstlisting}
Our current formalization does not use proof trees in an essential way, but we defined them so that we can define manipulations on proof trees (like detour elimination) in future projects.
We prove various meta-theoretic properties about provability, like weakening and the substitution theorem.
\begin{lstlisting}
def weakening : Γ ⊆ Δ → Γ ⊢ A → Δ ⊢ A
def substitution : Γ ⊢ A →
    (λ f, f[s // n]) '' Γ ⊢ A[s // n]
\end{lstlisting}
\subsection{ZFC}
\label{subsection:fol:zfc}

Usually, the language of set theory has one binary relation symbol and no function symbols.
In order to make the language a bit easier to work with, and to formulate the continuum hypothesis in a manageable way, we additionally add five function symbols to our language.
The five symbols we add are for the empty set \(\varnothing\), ordered pairs \(({-},{-})\), natural numbers \(\omega\), the power set \(\mathcal{P}({-})\) and the union \(\bigcup({-})\).
This gives a conservative extension of the regular theory of ZFC, because they are all definable.
As part of our future work, we want to formalize these facts, so that we actually prove the independence of the continuum hypothesis in a language with only one non-logical symbol.

The theory \(\ZFC\) we use consists of eight axioms and a strong version of the axiom schema of collection.
Five of the axioms characterize the function symbols we added.
The axioms of empty set, and powerset are similar to the usual formulation, except that we use the function symbols explicitly.
We don't uniquely characterize ordered pairs, but specify the equality on ordered pairs:
\[(x,y)=(z,w) \iff x = z \wedge y = w.\]
We don't have the usual axiom of pairing, but this axiom is derivable from the other axioms.
Our version of the axiom of infinity is a bit different to the usual axiom of infinity, which only specifies that there is an infinite set. Instead, we specify $\omega$ as the least limit ordinal.

In addition to the axioms characterizing the function symbols, we have the axioms of extensionality and regularity and Zorn's lemma.
Our version of Zorn's lemma is states that any non-empty collection of sets closed under unions of $\in$-chains has a maximal element.
Finally, the axiom schema of collection we use states that for every formula \(\varphi(x,y,\vec p)\) we have the axiom stating that if \(\varphi(x,y,\vec p)\) is a total relation with parameters \(\vec p\), then its image is a set:
\begin{gather*}
\forall p \forall u, (\forall x \in u, \exists y, \varphi(x,y,p)) \Rightarrow\\
(\exists v, \forall w, w \in v \iff \exists z \in u, \varphi(z,w,p)).
\end{gather*}

Now the continuum hypothesis \(\CH\) we use states that there is no ordinal between \(\omega\) and \(\mathcal{P}(\omega)\). It is defined to be the sentence
\[\CH:=\forall x, \Ord(x) \Rightarrow x \le \omega \vee \mathcal{P}(\omega) \le x,\]
where \(\Ord(x)\) means ``\(x\) is an ordinal'' and \(x \le y\) means that there is a surjection from a subset of \(y\) to \(x\). In code, we can formulate the \(\CH\) as follows.
\begin{lstlisting}
def CH_formula : formula L_ZFC' :=
∀' (is_ordinal ⟹
  leq_f[omega_t//1] ⊔ leq_f[Powerset_t omega_t//0])
\end{lstlisting}
Here the substitution ensures that the inequality \lil{leq_f} is applied to the correct arguments, and \lil{⊔} is notation for disjunction.

\section{Boolean-valued semantics}
\label{section:boolean-semantics}

A \textbf{complete Boolean algebra} is a boolean algebra $\B$ with as additional operations the infimum $\bigsqcap$ and supremum $\bigsqcup$ of any subset of $\B$.
We use $\sqcap, \sqcup, \implies, \top$, and $\bot$ to denote meet, join, material implication, and top/bottom elements.
For more details on complete Boolean algebras, we refer the reader to the textbook of Halmos-Givant~\cite{givant2008introduction}.

\begin{defn}\label{def-boolean-valued-structure}
  Fix a language $L$ and a complete Boolean algebra $\B$. A \textbf{$\B$-valued structure} is a type $M$ with realizations of all functions and relations in the language and a $\B$-valued congruence relation for equality. More precisely, it is an instance of the following structure:
  \begin{lstlisting}
structure bStructure (L : Language.{u}) :=
(carrier : Type u)
(fun_map {n} : L.functions n →
    vector carrier n → carrier)
(rel_map {n} : L.relations n →
    vector carrier n → 𝔹)
(eq : carrier → carrier → 𝔹)
(eq_refl (x) : eq x x = ⊤)
(eq_symm (x y) : eq x y = eq y x)
(eq_trans (x y z) : eq x y ⊓ eq y z ≤ eq x z)
(fun_congr {n} (f : L.functions n)
    (x y : vector carrier n) :
    ⨅(map2 eq x y) ≤
    eq (fun_map f x) (fun_map f y))
(rel_congr {n} (R : L.relations n)
    (x y : vector carrier n) :
    ⨅(map2 eq x y) ⊓ rel_map R x ≤
    rel_map R y)
\end{lstlisting}
Here ``\lstinline{⨅(map2 eq x y)}'' means ``the infimum of the list whose $i$-th entry is \lil{eq (x[i]) (y[i])}''.
\end{defn}

Given a preterm \lil{t} in the language, we can realize it in any $\B$-valued structure $M$.
For this, we need to know the free variables in \lil{t}.
To do this conveniently with de Bruijn variables, we say that a (pre)term \lil{t} is \emph{bounded by \lil{l}} if all free variables are less than \lil{l} (i.e. all variables under \lil{k} quantifiers are less than \lil{k+l}).
Given \lil{t : preterm n} which is bounded by \lil{l}, and a realization \lil{v : vector M l} of the free variables, we define the realization $\llbracket t \rrbracket_M^v : M^n \to M$ by structural recursion on $t$.

For a formula $\varphi$ we do the same: we define bounded (pre)formulae, and define an realization $\llbracket \varphi \rrbracket_M^v : M^n \to \B$ by structural recursion.
If $\varphi$ is a sentence, the realization in a structure is just a element of the boolean algebra: $\llbracket \varphi \rrbracket_M : \B$.

Since the truth values in a boolean-valued model live inside the boolean algebra $\B$ instead of just being true or false, we have to take a little care when stating the soundness theorem for boolean-valued models.
Usually, a soundness theorem states something like ``if $\varphi$ is provable from hypotheses in $\Gamma$ then in every model where $\Gamma$ holds, $\varphi$ also holds.''
With boolean truth-values, we need instead state it as an inequality of truth values. This motivates the following definition
\begin{defn}
We say that a set of sentences $\Gamma$ \emph{forces a sentence} $\varphi$, written $\Gamma \models_{\B}\varphi$, if for all non-empty $\B$-valued structures $M$ we have $\big(\bigsqcap_{\psi\in\Gamma}\big \llbracket \psi \rrbracket_M)\le\llbracket \varphi \rrbracket_M$.
\end{defn}
Using this definition, we can now state the boolean-valued soundness theorem:
\begin{lstlisting}
theorem boolean_soundness {Γ : set (sentence L)}
    {ϕ : sentence L} : Γ ⊢ ϕ → Γ ⊨[𝔹] ϕ
\end{lstlisting}
The proof is a straightforward structural induction.

\section{Boolean-valued models of set theory}
\label{section:bset}
\subsection{The Aczel encoding}
Our starting point is the Aczel encoding of \(\mathsf{ZFC}\) (\cite{aczel1978type, aczel1986type, aczel1982type}) into dependent type theory.
This was implemented in Coq by Werner \cite{werner1997sets}, and in Lean's \textsf{mathlib} by Carneiro \cite{mario1}.
The idea is to take a type universe \lstinline{Type u} and imitate the cumulative hierarchy construction with an inductive type:
\begin{lstlisting}
inductive pSet : Type (u+1)
| mk (α : Type u) (A : α → pSet) : pSet
\end{lstlisting}
For an element \lil{x = ⟨α, A⟩ : pSet}, the function \lil{A} points to the elements of \lil{x}.
We can define the empty set as \lstinline{∅ := ⟨empty, empty.elim⟩ : pSet}.
Note that \lil{pSet} does not satisfy the axiom of extensionality.
In order to obtain a model where the axiom of extensionality holds, we must quotient \lstinline{pSet} by \emph{extensional equivalence} \lil{≈}.
We have to be a bit careful with defining extensional equivalence.
Although extensional equivalence and membership are easily defined in terms of each other,
one has to be careful to make sure the definition is well-founded.
\begin{lstlisting}
x ≈ y ↔ ∀w, w ∈ x ↔ w ∈ y
x ∈ ⟨α, A⟩ ↔ ∃a, x ≈ A a
\end{lstlisting}
In order to make this well-founded, equivalence is defined by structural recursion:
\begin{lstlisting}
def equiv : pSet → pSet → Prop
| ⟨α,A⟩ ⟨β,B⟩ := (∀a, ∃b, equiv (A a) (B b)) ∧
  (∀b, ∃a, equiv (A a) (B b))
\end{lstlisting}

We can now membership from equivalence and check that modulo extensional equivalence, \lstinline{pSet} is a model of \(\mathsf{ZFC}\).

% \paragraph{Two roads to \lstinline{bSet}}
% We describe two ways by which one can start at the ordinary model of \(\mathsf{ZFC}\) \lstinline{pSet} and end with a Boolean-valued model \lstinline{bSet}.

% First, note that we can construct a model of \(\mathsf{ZFC}\) roughly equivalent to \lstinline{pSet} as follows:
% \begin{lstlisting}
% inductive bSet : Type (u+1)
% | mk (α : Type u) (A : α → bSet)
%   (B : α → bool): bSet
% \end{lstlisting}
% At first glance, \lstinline{bSet} adds large amounts of unnecessary information---while with \lstinline{pSet}, anything pointed to by an indexing function \lstinline{A} is a member of a set, \lstinline{bSet} only counts what is also assigned \lstinline{tt : bool}---and we can reconstruct \lstinline{pSet} from \lstinline{bSet} by recursively discarding anything which is assigned \lstinline{ff : bool} anyways. However, if we remember that \lstinline{bool} is a complete Boolean algebra \lstinline{⟨bool, ⊤, ⊥, ⊓, ⊔, ⨅,⨆, ⟹⟩}, then an upshot of the definition of \lstinline{bSet} is that we can replace the obvious analogue of \lstinline{equiv}
% \begin{lstlisting}
% def equiv : ∀ (x y : bSet), Prop
% | ⟨α,A,A'⟩ ⟨β,B,B'⟩ := (∀ a : α, A' a = tt → ∃ b : β, B' b = tt ∧ equiv₁ (A a) (B b)) ∧ (∀b : β, B' b = tt → ∃ a : α, A' a = tt ∧ equiv₁ (A a) (B b))
% \end{lstlisting}
% with a version which avoids propositional operations and only uses the operations of a complete Boolean algebra:\footnote{Assuming \lstinline{Prop ≃ bool}, which is provable using classical logic in Lean.}
% \begin{lstlisting}
% def equiv₂ : ∀ (x y : bSet), bool
% | ⟨α,A,A'⟩ ⟨β,B,B'⟩ := ⨅ a : α, A' a ⟹ ⨆ b : β, B' b ⊓ equiv₂ (A a) (B b) ⊓  ⨅ b : β, B' b ⟹ ⨆ a : α, A' a ⊓ equiv₂ (A a) (B b)
% \end{lstlisting}
% Since this definition only interfaces with the typeclass of complete Boolean algebras, we can replace \lstinline{bool} by an arbitrary complete Boolean algebra \lstinline{𝔹} throughout, yielding: % note(jesse, October 03 2019, 05:06 PM): maybe should emphasize definition of membership instead of equality to make it clear that these things are Boolean-valued models of ZFC
% \begin{lstlisting}
% inductive bSet (𝔹 : Type u) [complete_boolean_algebra 𝔹]: Type (u+1)
% | mk (α : Type u) (A : α → bSet)
%   (B : α → 𝔹): bSet
% \end{lstlisting}
% which we later verify is a \(\mathbb{B}\)-valued model of \(\ZFC\).

\subsection{Boolean-valued sets}
We now want to generalize \lil{pSet} to a Boolean-valued model of \(\ZFC\). In order to do this, we need to give a
\(\B\)-valued relation that corresponds to membership \lil{∈}. We encode this information, by adding an extra field to elements of \lil{pSet}, which is a \(\B\)-valued predicate.
\begin{lstlisting}
inductive bSet (𝔹 : Type u)
    [complete_boolean_algebra 𝔹] : Type (u+1)
| mk (α : Type u) (A : α → bSet)
    (B : α → 𝔹) : bSet
\end{lstlisting}
The predicate \lil{B} expresses that \lil{A a ∈ ⟨α, A, B⟩} has truth value (at least) \lil{B i}.

This is closely related to the recursive \emph{name}-construction from forcing, a key ingredient to building forcing extensions. Let \(\mathbb{P}\) be a poset. From e.g.\ Kunen \cite{kunen2014set}, Definition IV.2.5:
\begin{defn}
  A set \(\tau\) is a \(\mathbb{P}\)-name iff \(\tau\) is a relation and for all \(\langle  \sigma, p\rangle \in \tau\) we have that \(\sigma\) is a \(\mathbb{P}\)-name and \(p \in \mathbb{P}\).
\end{defn}
\lstinline{bSet 𝔹} should be thought of as the type of \lstinline{𝔹}-names, where the relation of \lil{⟨α, A, B⟩} is given by \lstinline"{ ⟨A i, B i⟩ | i ∈ α }".
The definitions are not exactly the same, as \lil{A} need not be injective, but we can define the same operations on \lil{bSet 𝔹} as on \lil{𝔹}-names.

% In particular, if \(\mathbb{P}\) is the singleton poset, then a \(\mathbb{P}\)-name is a set of \(\mathbb{P}\)-names, in the same way that a term of type \lstinline{pSet} is a type-indexed collection of terms of type \lstinline{pSet}.
% Reversing this observation, we replace \(\mathbb{P}\) with a complete Boolean algebra \(\mathbb{B}\) and generalize the definition of \lstinline{pSet.mk} with a third field, so that as in the case of \(\mathbb{P}\)-names, every element of a set is assigned an element (a ``Boolean truth-value'') of \(\mathbb{B}\):
% \begin{lstlisting}
% inductive bSet {𝔹 : Type u) : Type (u+1)
% | mk (α: Type u) (A: α → bSet) (B: α → 𝔹) : bSet
% \end{lstlisting}
% Whatever is important in \lstinline{bvm}, \lstinline{bvm_extras}, \lstinline{bvm_extras2} for this argument.

% \subsection{Boolean-valued equality and membership}
We can define Boolean-valued equality and membership analogously to the definitions in \lil{pSet}.
To do this, we have to translating quantifiers and connectives into operations on $\B$:
\begin{lstlisting}
def bv_eq : bSet 𝔹 → bSet 𝔹 → 𝔹
| ⟨α, A, B⟩ ⟨α', A', B'⟩ :=
  (⨅a, B a ⟹ ⨆a', B' a' ⊓ bv_eq (A a) (A' a')) ⊓
  (⨅a', B' a' ⟹ ⨆a, B a ⊓ bv_eq (A a) (A' a'))
\end{lstlisting}

We abbreviate \lil{bv_eq} with the infix operator \lil{=ᴮ}.
It is now easy to define $\B$-valued membership, which we denote by \lil{∈ᴮ}.
\begin{lstlisting}
def mem : bSet 𝔹 → bSet 𝔹 → 𝔹
| x ⟨α, A, B⟩ := ⨆a, B a ⊓ x =ᴮ A a
\end{lstlisting}

\subsection{The fundamental theorem of forcing}

The fundamental theorem of forcing for Boolean-valued models~\cite{hamkins2012well} states that for any complete Boolean algebra \lil{𝔹}, the type \lil{bSet 𝔹} forms a Boolean-valued model of $\mathsf{ZFC}$.

Bell~\cite{bell2011set} gives an extremely detailed account of the verification of the $\mathsf{ZFC}$ axioms,
and we faithfully followed his presentation for this part of the formalization.
Although most of the argument is routine, we describe some aspects of \lil{bSet 𝔹} which are revealed by this verification.

We can define subsets of a set $x$ by just modifying the last component of $x$.
This gives a nice definition of powerset:
\begin{defn} \label{def-powerset}
  Fix a $\B$-valued set \lil{x = ⟨α, A, b⟩} and \lil{χ : α → 𝔹} be a function.
  We can define the $\B$-valued set $\tilde{\chi}$ as \lil{⟨α, A, χ⟩}.
  The \textbf{powerset} $\mathcal{P}(x)$ of $x$ is defined to be the \lil{𝔹}-valued set,
  \[\langle \alpha \to \B,\ \widetilde{({-})},\ (\lambda\;\chi, \tilde{\chi} \subseteq^B x)\rangle.\]
\end{defn}

% \subparagraph*{The axiom of infinity}
% \lil{ω : pSet} is defined to be the collection of all finite von Neumann ordinals (via induction on $\mathbb{N}$), and we define \lil{ω : bSet 𝔹} as \(\check{\omega}\).
% Now \lil{ω} is the $\subseteq$-least set that contains $\varnothing$ and is closed under the successor operation $x \mapsto x \cup \{x\}$.
% More generally, we define a map \lil{ordinal.mk : ordinal → pSet} by transfinite recursion.

% \subparagraph*{The axiom of powerset}

% \subparagraph*{The axiom of choice}
Following Bell, we verified Zorn's lemma in \lil{bSet 𝔹}.
As is the case with \lil{pSet}, establishing Zorn's lemma requires the use of a choice principle from the metatheory.
This was the most involved part of our verification of the fundamental theorem of forcing, and relies on the technical tool of \emph{mixtures}, which allow sequences of $\B$-valued sets to be ``averaged'' into new ones.
It also uses the \emph{maximum principle}, which allows existentially quantified statements to be instantiated without changing their truth-value. % TODO: expand

% \subparagraph*{The smallness of \ $\B$}
% We end this section by remarking that the ``smallness'' of $\B$ (or more precisely, the fact that $\B$ lives in the same universe of types out of which \lil{bSet 𝔹} is being built) is essential in making \lstinline{bSet 𝔹} a model of $\mathsf{ZFC}$.
% It is required for extracting the witness needed for the maximum principle, and is also required to even define the powerset operation, because the underlying type of the powerset is the function type of all maps into \lstinline{𝔹}.

% \subparagraph*{Check-names}
\begin{defn}\label{def-check}
  We define the canonical map \lil{check : pSet → bSet 𝔹} by
  \begin{lstlisting}
  def check : pSet → bSet 𝔹
  | ⟨α,A⟩ := ⟨α, check ∘ A, (λ a, ⊤)⟩
  \end{lstlisting}
  We also write $\check{x}$ for \lil{check x}, and call it a \emph{check-name}.
  % We call members of the image of \lil{check} \emph{check-names}, %\footnote{This terminology is standard, c.f. \cite{hamkins2012well, moore2019method}.}
  These are also known as \emph{canonical names}, as they are the canonical representation of standard two-valued sets inside a Boolean-valued model of set theory.\footnote{We were pleased to discover Lean's support for custom notation allowed us to declare the Unicode modifier character \texttt{U+030C} ($\check{\hspace{1mm}}$) as a postfix operator for \texttt{check}.}
\end{defn}

\subparagraph*{ordinals in $\B$}
We can define a map \lil{ordinal.mk : ordinal → pSet} by transfinite recursion.
If we compose this map with \lil{check} we get the ordinals in \lil{bSet 𝔹}.
In particular, we get the least infinite ordinal \lil{ω : bSet 𝔹}, which witnesses the axiom of infinity.
% \lil{ω : pSet} is defined to be the collection of all finite von Neumann ordinals (via induction on $\mathbb{N}$), and we define \lil{ω : bSet 𝔹} as \(\check{\omega}\).
% Now \lil{ω} is the $\subseteq$-least set that contains $\varnothing$ and is closed under the successor operation $x \mapsto x \cup \{x\}$.


We summarize the relationship between the three ``large'' types currently in play:
\[
  \begin{tikzcd}
    % & \text{\lstinline{Type u+1}} & & \\
    \texttt{pSet} \arrow{rr}{\texttt{check}} & & \texttt{bSet } \mathbb{B} & \\
    & & & \\
    \texttt{ordinal.\{u\}} \arrow{uu}{\texttt{ordinal.mk}} \arrow{uurr} & & & % \\
    % \hspace{0mm}  \arrow[dashed, no head]{rrr } & & & \hspace{0mm} \\
    % & \mathbb{B} & & \\
    % & \text{\lstinline{Type u}} & &
  \end{tikzcd}
\]

We spell out the name of Lean ordinals and cardinals, and use (checked) Hebrew letters for their (Boolean-valued) set-theoretic counterparts, so that with respect to the above diagram, we have:
\[
  \begin{tikzcd}
    % & \text{\lstinline{Type u+1}} & & \\
    \aleph_1 \arrow[mapsto]{rr}{\texttt{check}} & & \widecheck{\aleph_1} & \\
    & & & \\
    \text{\lstinline{(aleph 1)}} \arrow[mapsto]{uu}{\texttt{ordinal.mk}} \arrow[mapsto]{uurr} & & & % \\
    % \hspace{0mm}  \arrow[dashed, no head]{rrr } & & & \hspace{0mm} \\
    % & \mathbb{B} & & \\
    % & \text{\lstinline{Type u}} & &
  \end{tikzcd}
\]


% TODO(jesse): add a note in the introduction on how Dana Scott was the first one to point out that the names could be taken at face value as a model of ZFC if one was willing to shift to a many-valued logic instead.


\section{Forcing} \label{section:forcing}
Our point of departure from conventional accounts of forcing with a poset \(\mathbb{P}\) over a countable transitive model \cite{kunen2014set, jech2013set}, which use a generic filter to ``evaluate'' the \lstinline{ℙ}-names and produce an ordinary model of \(\ZFC\), is to force with \emph{Boolean-valued models} of \(\ZFC\) instead. As first observed by Scott and Solovay \cite{scott-solovay}, this obviates the need for countable transitive models, generic filters, or the truth and definability lemmas, and allows us to work only with the \lstinline{𝔹}-names.

The cost of taking the \lstinline{𝔹}-names at face value is that the calculus of the forcing relation \cite{shoenfield1971unramified}, a key technical tool in usual forcing arguments, is replaced by the calculation of Boolean truth-values in \lstinline{𝔹}. From the Boolean-valued perspective, forcing a sentence \(\Phi\) in the language of \(\mathsf{ZFC}\) means constructing some \lil{𝔹} and a \lil{𝔹}-valued model \(M\) of \(\ZFC\) such that the truth value \(\Phi^{M}\) of \(\Phi\) is \(\top\). We will always force over a type universe \lil{Type u}, and our Boolean-valued models of \(\mathsf{ZFC}\) are always of the form \lil{bSet 𝔹} for some \lil{𝔹 : Type u}. That \lil{𝔹} belongs to {Type u} is crucial for forcing, as specific choices of \lil{𝔹} will affect the structure of \lil{bSet 𝔹} (and hence the truth-value of \(\Phi\)). % However, the effects of a particular choice of \lil{𝔹} is often only easily determined on the check-names, and a deeper combinatorial analysis of \lil{𝔹} is required to complete the argument.

In this section, we describe two forcing arguments, one for \(\neg \CH\) and another for \(\CH\). Both follow roughly the same pattern. In both cases, we require the existence of a function (for \(\neg \CH\), an injection \(\aleph_2 \hookrightarrow \mathcal{P}(\omega)\), and for \(\CH\), a surjection \(\aleph_1 \twoheadrightarrow \mathcal{P}(\omega)\).) We will construct a \lil{𝔹}  which encodes the construction (in \lil{Type u}) of such a function \(F\). Then \lil{𝔹} induces in \lil{bSet 𝔹} an approximation \(\widetilde{F}\) to such a function, which \emph{a priori} is only between check-names. To finish the forcing argument, we must show that it suffices to work with \(\widetilde{F}\). This requires a careful study of how truth-values are calculated in \lil{bSet 𝔹}, and ultimately reduces to an analysis of how truth-values in \lil{bSet 𝔹} can be reflected \emph{back} to \lil{Type u}, and verifying a combinatorial condition on \lil{𝔹}.

\subsection{Regular open algebras}
\begin{defn}\label{def-regular-open-algebra}
  Let $X$ be a topological space, and for any open set $U$, let $U^\perp$ denote the complement of the closure of $U$. The \textbf{regular open algebra} of a topological space $X$, written $\operatorname{RO}(X)$, is the collection of all open sets $U$ such that $U = (U^\perp)^\perp$, equipped with the structure of a complete Boolean algebra, with $x \sqcap y := x \cap y$, $x \sqcup y := ((x \cup y)^\perp)^\perp$, $\neg x := x^\perp$, and $\bigsqcup x_i := ((\bigcup x_i)^\perp)^\perp$.
\end{defn}

While forcing conditions usually present themselves as a poset instead of a complete Boolean algebra, any forcing poset can be represented as the dense suborder of a regular open algebra \cite{moore2019method}.

\begin{defn}\label{def-dense-suborder}
  A \textbf{dense suborder} of \(\B\) is a subset \(\mathbb{P} \subseteq \B\) satisfying the following conditions: (1) for all \(p \in \mathbb{P}\), \(\bot < p\); (2) for all \(\bot < b \in \B\), there exists a \(p \in \mathbb{P}\) such that \(p \leq b\).
\end{defn}

\begin{defn}\label{def-ccc}
We say that $\B$ has the \textbf{countable chain condition} (CCC) if every antichain $\mathcal{A} : I \to \B$ (i.e. an indexed collection of elements $\mathcal{A} := \{a_i\}$ such that whenever $i \neq j, a_i \sqcap a_j = \bot$) has a countable image.
\end{defn}

\begin{defn}\label{def-sigma-closed}
We say that \(\B\) is \textbf{\(\sigma\)-closed} if there exists a dense suborder \(\mathbb{P}\) of \(\B\) such that every \(\omega\)-indexed downwards chain \(p_0 \geq p_1 \geq \cdots \geq p_n \cdots\) in \(\mathbb{P}\) has a lower bound \(p_{\omega}\) in \(\mathbb{P}\).
\end{defn}

\subsection{Cohen forcing}

As we have already seen \ref{def-powerset}, we construct the powerset of a \lil{𝔹}-valued set \lstinline{u : bSet 𝔹} using \lil{𝔹}-valued indicator functions \lil{χ : u.type → 𝔹}. The basic strategy of Cohen forcing is to choose \lil{𝔹} such that for every \(\nu : \aleph_2\), there is a canonical indicator function (a ``Cohen real'') \(\chi_{\nu} : \omega \to \mathbb{B}\). This is an external function (a member of a function type of \lstinline{Type u}) which we check descends to an injective function \lil{ℵ₂̌  → 𝒫(ω)} in \lil{bSet 𝔹}. To show that this injection suffices to negate \(\CH\), we show that if \lil{𝔹} satisfies the CCC, then \(\omega \prec \check{\aleph_1} \prec \check{\aleph_2} \preceq \mathcal{P}(\omega)\), and ensure that our choice of \lil{𝔹} has this property.

\begin{defn}
  The \textbf{Cohen poset} for adding $\aleph_2$-many Cohen reals is the collection of all finite partial functions $\aleph_2 \times \mathbb{N} \to \mathbf{2}$, ordered by reverse inclusion.
\end{defn}

In the formalization, the Cohen poset is represented as a \lstinline{structure} with three fields:
\begin{lstlisting}
structure ℙ_cohen : Type :=
  (ins : finset (ℵ₂.type × ℕ))
  (out : finset (ℵ₂.type × ℕ))
  (H : ins ∩ out = ∅)
\end{lstlisting}

%TODO(jesse): reword
That is, we identify a finite partial function $f$ with the triple \lil{⟨f.ins, f.out, f.H⟩}, where \lil{f.ins} is the preimage of $\{1\}$, \lil{f.out} is the preimage of $\{0\}$, and \lil{f.H} ensures well-definedness. While $f$ is usually defined as a finite partial function, we found that in practice $f$ is really only needed to give a finite partial specification of a subset of $\aleph_2 \times \mathbb{N}$ (i.e. a finite set \lil{f.ins} which \emph{must} be in the subset, and a finite set \lil{f.out} which \emph{must not} be in the subset), and chose this representation to make that information immediately accessible.

The Boolean algebra which we will use for forcing $\neg\mathsf{CH}$ is \lil{𝔹_cohen := } $\operatorname{RO}(2^{\aleph_2 \times \mathbb{N}})$, where we equip $2^{\aleph_2 \times \mathbb{N}}$ with the usual product space topology.

\begin{defn}
  We define the \textbf{canonical embedding} of the Cohen poset into $\B$ as follows:
  \begin{lstlisting}
def ι : 𝒞 → 𝔹 := λ p, {S | p.ins ⊆ S ∧ p.out ⊆ - S}
\end{lstlisting}
\end{defn}
That is, we send each \lil{c : 𝒞} to all the subsets which satisfy the specification given by \lil{c}. This is a clopen set, hence regular. Crucially, this embedding is \emph{dense}:
\begin{lstlisting}
lemma 𝒞_dense {b : 𝔹} (H : ⊥ < b) : ∃ p : 𝒞, ι p ≤ b
\end{lstlisting}
Recalling that $\leq$ in $\B$ is subset-inclusion, we see that this is essentially because the image of $\iota : \mathcal{C} \to \B$ \emph{is} the standard basis for the product topology. Our chosen encoding of the Cohen poset also made it easier to perform this identification when formalizing this proof.

\subsection{Collapse forcing} \label{subsection:collapse}
% note(jesse, October 01 2019, 04:11 PM): i think levy collapse only involves the collapse of strongly inaccessible cardinals, and that the collapsing argument we use goes by the name of σ-closed, ω-closed, countably closed forcing or maybe just collapse forcing? we should clarify this.

Whereas Cohen forcing creates a new injection \(\check{\aleph_2} \hookrightarrow \mathcal{P}(\omega)\), we can use \emph{collapse forcing} to create a new surjection \(F : \aleph_1 \twoheadrightarrow \mathcal{P}(\omega)\). Similarly to Cohen forcing, the strategy is to pick \lil{𝔹} such that there is a canonical \lil{𝔹}-valued indicator function on \(\check{\aleph_1} \times \check{\mathcal{P}(\omega)}\) representing the graph of a surjection \(\widetilde{F}\). To show that \(\widetilde{F}\) suffices to force \(\CH\), we must show that \(\check{\aleph_1} = \aleph_1\), and that \(\check{\mathcal{P}(\omega)} = \mathcal{P}(\omega).\) Both equalities follow from being able to lift functions \(\omega \to \check{y}\) to functions \(\omega \to y\); this will follow from ensuring our choice of \(\mathbb{B}\) is \(\sigma\)-closed (\ref{def-sigma-closed}).

\begin{defn}\label{def-collapse-poset}
  We define \lstinline{ℙ_collapse} to be the poset of countable partial functions \(\aleph_1 \to \mathcal{P}(\omega)\). The principal open sets \[D_p := \{g : \aleph_1 \to \mathcal{P}(\omega) \hspace{2mm} | \hspace{2mm} g \text{ extends } p\} , \hspace{3mm} p \in \mathbb{P}_{\text{collapse}}\] form the basis of a topology \(\tau\) (finer than the product topology) on the function set \(\mathcal{P}(\omega)^{\aleph_1}\). We put
  \begin{center}
  \lstinline{𝔹_collapse :=} \(\operatorname{RO}\left(\mathcal{P}(\omega)^{\aleph_1}, \tau\right)\).
  \end{center}
\end{defn}

\begin{remark}
  As an implementation detail, in the formalization we \emph{define} \lil{ℙ_collapse} to be the countable partial functions (in \lil{Type u}) between \lil{(ordinal.mk (aleph one) : pSet).type} and \lil{(powerset omega : pSet).type}, so that \\\lil{𝔹_collapse}-valued indicator functions on \lil{ordinal.mk (aleph one) : pSet).type × (powerset omega : pSet).type} are definitionally equal to \lil{𝔹_collapse}-valued indicator functions on the underlying types of \lil{check (ordinal.mk (aleph one))} and \lil{check (powerset omega)}.
\end{remark}

In \lil{bSet 𝔹_collapse}, we can specify the indicator function \(\chi_{\pi}\) of the graph of a function \lil{π : ℵ₁̌  → 𝒫(ω)̌ } as follows: to an \(\eta < \aleph_1\) and a subset \(S \subseteq \mathcal{P}(\omega)\) (in \lil{pSet}), we attach the \emph{principal open} (comprising functions extending the singleton countable partial function \(\{(\eta, S)\}\)):
\[
  \chi_\pi (\eta, S) := D_{\{(\eta, S)\}} = \{g : \aleph_1 \to \mathcal{P}(\omega) \operatorname{|} g (\eta) = S\}.
\]

More generally, we formalize conditions over generic \lil{x, y : pSet} and \lil{𝔹} for when a function \lil{af : x.type → y.type → 𝔹} induces a surjection \lil{x̌ → y̌} in \lil{bSet 𝔹}. By definition, such a function always induces a relation. Surjectivity is equivalent to \lil{⨅ j, (⨆ i, af i j) = ⊤}, totality is equivalent to \lil{⨅ i, (⨆ j, af i j) = ⊤}, and well-definedness follow from the following two conditions:
\begin{lstlisting}
∀ i, ∀ j₁ j₂, j₁ ≠ j₂ → af i j₁ ⊓ af i j₂ ≤ ⊥
  ∀ i₁ i₂, ⊥ < (func x i₁) =ᴮ (func x i₂) → i₁ = i₂
\end{lstlisting}

Both surjectivity and totality of \(\chi_{\pi}\) require \emph{denseness arguments}, where the definition of indexed supremum (\(\bigsqcup x_i\)) in the regular open algebra as the regularization \(((\bigcup x_i)^\perp)^\perp\) of the set-theoretic union plays a key role: the union of the truth values is not the entire space, but is only a dense open whose regularization is the entire space. In particular, the denseness argument for surjectivity crucially uses that \(\aleph_1\) is uncountable while \(\omega\) is countable.


\begin{itemize}
 \item To specify the surjection \(\aleph_1 \twoheadrightarrow \mathcal{P}(\omega)\), need to specify a subset of the powerset \(\mathcal{P}(\aleph_1 \times \mathcal{P}(\omega))\).

 \item Let \(p(\nu, S)\) be the (singleton) countable partial function which sends \(\nu : \aleph_1\) to \(S : \mathcal{P}(\omega)\).

 \item Then we can check that the indicator function
\[ (\nu, S) \mapsto D_{p(\nu,S)}, \]
induces a surjection in \lstinline{bSet 𝔹_collapse} from \(\check{\aleph_1}\) to \(\check{\mathcal{P}(\omega)}\).

 \item Then it remains to check that \(\check{\aleph_1} = \aleph_1\) and \(\mathcal{P}(\omega) = \check{\mathcal{P}(\omega)}\)
\end{itemize}

\paragraph{Function reflection}

This follows from the following property: for any \lstinline{y : pSet}, and for any \lstinline{f : bSet 𝔹_collapse}, if \lstinline{bSet 𝔹_collapse} thinks that \(f : \check{\omega}  \to \check{y}\) is a function, then there exists a \(g : \omega \to y\) *in* \lstinline{pSet} such that \(\check{g} = \check{f}\).

As before, reflect a boolean-valued \(\forall \exists\) statement into the metatheory. The following lemma is always true:
%TODO(jesse): make this bigger

\begin{lstlisting}
lemma AE_of_check_func_check (x y : pSet.{u}) {f : bSet 𝔹} {Γ : 𝔹}
  (H : Γ ≤ is_func' (x̌) (y̌) f) (H_nonzero : ⊥ < Γ) :
  Π (i : x.type),
    ∃ (j : y.type ) (Γ' : 𝔹) (H_nonzero' : ⊥ < Γ') (H_le : Γ' ≤ Γ),
      Γ' ≤ (is_func' (x̌) (y̌) f) ∧ Γ' ≤ (pair ((x.func i)̌ ) ((y.func j)̌ )) ∈ᴮ f :=
\end{lstlisting}

Recursively applying this lemma, obtain values \(g_0, \dots, g_n, \dots\) such that

\[\bot < \dots < \left(\bigsqcap_{k \leq n} ((k, g_k) \in^{\mathbb{B}} g)\right) < \cdots < ((0 , g_0) \in^{\mathbb{B}} g)\]

The intersection of this chain thinks that \(g\) is the required lift of \(f\). In general, this intersection might be empty, but it is nonempty for \lstinline{𝔹_collapse}, (essentially) because the union of a chain of countable partial functions is again a countable partial function. By another denseness argument, \(g\) has the required property.

\paragraph{Concluding remarks} %TODO(jesse) remove this header

% TODO(jesse): reorganize and put into other sections
% To prove that the regular open algebra RO (2^(aleph_2 x omega)) for Cohen forcing has the CCC, a much more direct argument suffices. Given an antichain of regular opens, shrink them to basic clopens, which can then be identified with finite partial functions (p_i : aleph_2 x omega -> 2). Disjointness is equivalent to the finite partial functions all disagreeing with each other at some point. It suffices to show that for every n : N that there are only finitely many p_i of cardinality n. It's easy to see this for n = 1, and at the induction step, fix some p* and towards a contradiction if there are infinitely many, then we can use the pigeonhole principle to get an infinite subfamily (q_i) which disagree with p* at the same point. Then the (q_i) agree at that point, so that point can be removed, contradicting the induction hypothesis.

% This is indeed more delicate than proving the corresponding combinatorial property on the forcing CH side, where we just observe that a countable union of countable partial functions is again a countable partial function, but after this point the rest of the Cohen forcing argument is very easy (I just checked and we actually don't use a denseness argument at all), while collapse forcing uses denseness in an essential way in multiple places.



% partial functions in Lean, introduce the collapsing boolean algebra, show omega-closedness.

\subsection{Construction of $\aleph_1$} \label{subsection:forcing:aleph-1}

% Construction of $\aleph_1$.

\subsection{The independence of CH} \label{subsection:forcing:independence}

\begin{lstlisting}
theorem CH_unprovable_from_ZFC : ¬ (ZFC' ⊢' CH_sentence) :=
unprovable_of_model_neg (V 𝔹_cohen) fundamental_theorem_of_forcing
  (nontrivial.bot_lt_top) V_𝔹_cohen_models_neg_CH

theorem neg_CH_unprovable_from_ZFC : ¬ (ZFC' ⊢' ∼CH_sentence) :=
unprovable_of_model_neg (V 𝔹_collapse) fundamental_theorem_of_forcing
  (nontrivial.bot_lt_top) (by {rw forced_in_not, from V_𝔹_collapse_models_CH})

def independent {L : Language} (T : Theory L) (f : sentence L) : Prop :=
¬ (T ⊢' f ∨ T ⊢' ∼f)

theorem independence_of_CH : independent ZFC' CH_sentence :=
by finish[independent, CH_unprovable_from_ZFC, neg_CH_unprovable_from_ZFC]
\end{lstlisting}

\section{Automation and metaprogramming}
\label{section:metaprogramming}

Mention same stuff as in slides + ITP paper; also mention \lstinline{bv_cc} and the usefulness of quotient types for boolean-valued equality reasoning.

\section{Related Work}
\label{section:related-work}
Compare with other formalization on the consistency of CH.

\section{Conclusions}
\label{section:conclusions}
Future work: construction of L, ZFC without function symbols, parser and better printer for FOL

%% Acknowledgments
\begin{acks}                            %% acks environment is optional
                                        %% contents suppressed with 'anonymous'
  %% Commands \grantsponsor{<sponsorID>}{<name>}{<url>} and
  %% \grantnum[<url>]{<sponsorID>}{<number>} should be used to
  %% acknowledge financial support and will be used by metadata
  %% extraction tools.
  The authors gratefully acknowlege the support by the
  \grantsponsor{GS100000001}{Alfred P. Sloan Foundation}{https://doi.org/10.1038/201765d0}, Grant
  No.~\grantnum{GS100000001}{G-2018-10067}.
\end{acks}

%% Bibliography
\bibliography{flypitch-cpp}

%% Appendix
% \appendix
% \section{Appendix}

% Text of appendix \ldots

\end{document}
